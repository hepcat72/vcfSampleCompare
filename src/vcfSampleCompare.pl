#!/usr/bin/env perl

#USAGE: Run with no options to get usage or with --help for basic details

#Robert W. Leach
#Princeton University
#Carl Icahn Laboratory
#Lewis Sigler Institute for Integrative Genomics
#Bioinformatics Group
#Room 137A
#Princeton, NJ 08544
#rleach@princeton.edu
#Copyright 2019

use warnings;
use strict;
use CommandLineInterface;

our $VERSION = '2.013';
setScriptInfo(VERSION => $VERSION,
              CREATED => '6/22/2017',
              AUTHOR  => 'Robert William Leach',
              CONTACT => 'rleach@princeton.edu',
              COMPANY => 'Princeton University',
              LICENSE => 'Copyright 2019',
              HELP    => << 'END_HELP'

This script answers the question "What's different?" between my samples. It does this by sorting and filtering the variant records of a VCF file (containing data for 2 or more samples) based on the differences in the variant data between samples. The end result is a file containing the variants that show the biggest difference at the top and variants with no or little difference at the bottom or filtered out. Think of it as the genetic variant analog of a differential gene expression analysis. It solves the problem of finding "what's different" (for example) between wildtype and mutant samples.

Note, this tool does not perform a statistical analysis.  It is only meant to highlight whether differences exist between sample groups of interest.  It is not intended to be used as "proof" that differences between samples are "real" or biologically relevant.

Degree of "difference" between sample groups is determined by either genotype calls or the difference in the observation ratios (i.e. allelic frequencies "AO/DP") of a particular variant state (e.g. the number of times an 'A' is observed for a variant position over the number of reads that mapped over that position) between each sample group.  Run with `--help --extended` for more details on "degree of difference".

The variant state used to determine the difference between sample groups is the one leading to the greatest difference.  If there is a tie between reference (REF) and an alternate (ALT) variant states when computing the difference, the alternate state is the default selected variant state.

If multiple pairs of sample groups are provided, the pair used to represent the difference for a variant row is the one leading to the greatest degree of difference in genotype calls or observation ratios between sample groups.

If sample groups are not specified, the pair of sample groups leading to the greatest difference is greedily generated.

The sort is intended to bring variants whose degree of difference in genotype calls or allelic frequencies between sample groups to the top.

See --help --extended for more details.

END_HELP
	      ,
	      DETAILED_HELP => << 'END_AHELP'

This script works with VCF files generated by freeBayes (for SNP and small nucleotide variants) and svTyper (for structural variants).  However, it will also work with any VCF data produced by other tools as long as the output includes GT and/or (AO and RO), and DP tags in the FORMAT data column.

Each row in a VCF file will be assumed to represent a variant (or variant position).  In the context of this script, there are two ways to look at differences among the samples: genotype calls and the ratio of observations of a particular variant out of the total observations.  We'll refer to this as either "observation ratios" or "allelic frequencies" throughout this documentation.

SORTING

Sorting is based on genotype call scores (BEST_GT_SCORE), observation ratio scores (BEST_OR_SCORE), and read depth scores (BEST_DP_SCORE).  These score columns will always be between 0 and 1*.

When in --nogenotype mode, sorting ignores the BEST_GT_SCORE values.

* When `--gap-measure edge` is supplied, BEST_OR_SCORE can be negative (between -1 and 0) if the observation ratios overlap/mix, i.e. there is no gap separating all observation ratios of 1 group from the other.  A score of -1 is applied when all values in 1 group are bounded by the range of scores in the other group.

SORTING METRICS

All 3 scores on which sorting is based (BEST_DP_SCORE, BEST_GT_SCORE, and BEST_OR_SCORE) by default, are weighted in a 100:10:1 ratio, respectively.  The weighted sum of the scores is used for a descending sort.  To alter the weightings, see the --*-sort-weight options in the advanced usage (by running vcfSampleCompare.pl --extended 2).

The degree of difference between sample groups is based on the degree of difference of the genotype calls (BEST_GT_SCORE) and/or observation ratios (BESTOR_SCORE) between the sample groups reported.  In both cases, BEST_GT_SCORE and BEST_OR_SCORE are intended to reflect the maximum "degree of difference" between sample groups.

However, with regard to BEST_GT_SCORE, by default, scores are treated in a binary fashion.  A pair of sample groups either fully discriminates the 2 sample groups (a score of 1) or not (a score of 0).  See the advanced usage (by running `vcfSampleCompare.pl --extended --extended`) to allow partially discriminating variants using the --minimum-gt-score option.  A score of 0 can either mean that there were differing genotype calls between the sample groups or that none of the samples had a genotype call.  Despite the common score, cases of no data in all samples will be sorted to the bottom of the output.

The scores under the BEST_OR_SCORE column can be calculated in 1 of 2 ways (see --gap-measure), which either treats the collection of observation ratios for a single variant state (e.g. a SNP value of "C") as 2 ranges of separate or overlapping ratios (all between 0 and 1) or a comparison of average observation ratios.  Each variant state is considered independently and the one resulting in the highest BEST_OR_SCORE is the one that is used to represent the row.  Consider SNPs for example.  A SNP can have 1 of 4 values (A, T, G, or C).  One of those is the reference state (RO), which is referred to as state 0.  The other three states are 1, 2, and 3.  For each state, the observation ratios are computed as (RO or AO)/DP for all of the samples.  The state resulting in the highest score (i.e. the largest gap between the 2 ranges of observation ratios) is what is reported under the BEST_GT_SCORE column (see -u).  If there is a tie between RO and one of the AO values, the AO state (1, 2, or 3) is preferred.  For example, if state 1 is the state used to calculate the BEST_OR_SCORE, the ratio for each sample of AO(1)/DP is computed and those values for each group are used to compute the difference between the groups.

The BEST_DP_SCORE values are calculated as a degree of adequate depth (see --adequate-depth), where each sample/variant whose DP is at or above the adequate-depth gets a score of 1 and anything less is a value between 0 and 1.

If run in --nogenotype mode, the values in the BEST_OR_SCORE column of the output (see -u) reflect the only measure of degree of difference in the observation ratios (a.k.a. "allelic frequencies").

SAMPLE GROUP CONSTRUCTION AND ITS EFFECT ON SORTING

Sample group membership is what determines the BEST_GT_SCORE and BEST_OR_SCORE, which are used for sorting variant rows.  Thus, how groups are defined affects the sort of the variants.  The intention is to end up with variants at the top of the file that differ the most between sample groups of interest.  If you are primarily interested in the difference between pre-defined groups, setting those groups will cause the greatest differences between them to occur at the top of the results.

The composition of the sample groups can be user-defined or dynamically generated and depends on the --sample-group/-s, --min-group-size/-d, and --grow/--nogrow parameters.  Sample groups are constructed dynamically by default.  Since the BEST_[GT/OR]_SCORE column values are used for sorting and it is the GT, AO, RO, and DP values of the members of the sample groups that determines those values, parameters which affect the sample groupings will affect the sort.  The default behavior is to create 2 sample groups dynamically (unless --sample-group/-s is provided).

USER-DEFINED SAMPLE GROUPS

If you are interested in a comparison between 2 specific sets of samples, you can define them on the command line using 2 instances of the --sample-group parameter.  For example, if you have 3 wildtype replicates (wt1, wt2, and wt3) and 3 mutant replicates (mut1, mut2, and mut3), you can define them on the command-line like this:

    vcfSampleCompare.pl --sample-group 'wt1 wt2 wt3' --sample-group 'mut1 mut2 mut3' input.vcf

The values used must match the vcf file headers for those samples (appearing after the 'FORMAT' column header).  Each list is space-delimited and each group must be wrapped in quotes.

You can have multiple sample group pairs.  Each pair must occur in tandem (e.g. `-s 'pair1/group1...' -s 'pair1/group2...' -s 'pair2/group1...' -s 'pair2/group2...'`).  When given multiple pairs of sample groups to compare, only the pair resulting in the best score (i.e. biggest difference in BEST_GT_SCORE or BEST_OR_SCORE) will be reported.  In the event of a tie, the first pair defined on the command line will be the one reported.

By default, all samples in each group are used to calculate the score for the pair of groups.

Alternatively, if you are interested in at least N samples of group 1, that differ by genotype call or by at least the --separation-gap, with M samples of group 2 (and --grow is true), you can use the --min-group-size/-d parameter to supply the minimum number of members for each group (let's call them N & M for groups 1 & 2 respectively).  Note, either N or M must represent at least half the members of their respective group sizes in order to avoid the introduction of noise.  Unless --nogrow is supplied, vcfSampleCompare will try to add other samples in the defined group (over the supplied N and M values) until either all members of the group are included or there are no other samples with the same genotype call or the difference in their observation ratios would drop below the --separation-gap threshold.  Each group is sorted by the overall genotype call abundance of all samples or by their observation ratios ((AO or RO)/DP).  2 attempts are made to create each group: bottom-up versus top-down from the sorted sample groups respectively, and then vice versa (top-down versus bottom-up).  The first member of each group is the lowest/highest from group1/group2 respectively.  The second attempt is the reverse: highest/lowest from group1/group2.  If --grow is true (which is the default), 1 group member will be added to one of the groups, iteratively in a greedy fashion.  The group selected to grow at each iteration, using the member from the end of its list it is being constructed from, will be the one resulting in the highest separation gap.  Groups will stop growing when doing so would cause their genotype calls to include a call that is common between the groups or when doing so would cause the separation gap to exceed the --separation-gap threshold (or until all group members have been added).  For example:

    vcfSampleCompare.pl --sample-group 'wt1 wt2 wt3' --min-group-size 3 --sample-group 'mut1 mut2 mut3' --min-group-size 1 --separation-gap 0.6 --grow --nogenotype input.vcf

In this example, the separation score will be based on all wildtype samples and at least 1 mutant sample, though up to 3 mutant samples will be included in the mutant group as long as the resulting genotype calls between the groups differ or the gap between the observation ratios of the 2 groups is greater than or equal to 0.6.

If --nogrow is supplied, group sizes will reflect the --min-group-size.  Groups will not grow beyond the member samples defined using --sample-group.

Note, when multiple pairs of groups are submitted on the command line, each variant/row may be composed of a different pair of groups.  The selected pair is intended to represent the groupings that have greatest difference for that variant.  If there are multiple pairs of sample groups that are of interest, it is recommended to run vcfSampleCompare.pl multiple times, one for each pairing.  Supplying multiple pairs of groups is intended to be used when you do not know which samples have variants of interest.

The minimum possible score for user-defined sample groups is either -1 for scoring method 'edge' or 0 for scoring method 'mean'.  With the 'edge' scoring method, negative numbers indicate the degree of overlap/mix of the observation ratios.  A score of -1 means that one group's range of observation ratios contains the other.

DYNAMIC CREATION OF SAMPLE GROUPS

If no --sample-group(s) or --min-group-size(s) are supplied, 2 sample groups are constructed in the following manner: samples are sorted by their overall genotype call abundance or observation ratios and the sample at each end of the sorted list seeds 2 initial groups: one from the beginning of the list and one from the end (even if all genotype calls or observation ratios are the same).  Unless --nogrow is supplied (or until each group's --min-group-size is reached), the next sample (from either end of the remaining sorted list) that results in the largest separation gap (e.g. the difference between the averages of the observation ratios in the 2 groups) or continues to not produce common genotype calls between the 2 groups is added to its end-group.  Samples continue to be added to the groups, one by one, until the next sample added would cause a common genotype call between the groups or the difference in their observation ratios would go below the --separation-gap threshold (or in the case of --nogrow: until both groups' --min-group-size is reached).

Up to 2 --min-group-size's can be supplied, but must not sum to more than the total number of samples.  The default --min-group-size is 1 when --sample-group is not provided.

Each grouping is independent for each variant (i.e. each row in the VCF file).  Thus, when groups are dynamically created, each variant/row may be composed of different groups.  The selected groups are intended to represent the binary sample division that represents the greatest difference for that variant between 2 sample groups.  If there are more than 2 types of samples (e.g. multiple treatments and a control), dynamic creation of sample groups can miss significant differences and it is recommended to supply sample groupings in multiple runs of vcfSampleCompare.pl.

The minimum possible score when sample groups are dynamically created is 0, since the groups are created from a list sorted by either the genotype call or observation ratios (thus the difference in those values will always be positive).

Note: Minimum group sizes are dynamically created regardless of whether there exists a sample grouping that would pass the filter.  When --nofilter is supplied, sample groups that fail the filter will have a BEST_GT_SCORE or BEST_OR_SCORE of 0 and the sample grouping and size will be meaningless.

FILTERING

There are 2 options that can be used to filter variants that do not contain differences between the sample groups (--separation gap and --min-group-size) and the usage of those parameters for filtering dependes on the genotype mode (--genotype/--nogenotype).

In --genotype mode, you can use --min-group-size as a reporting threshold.  There must be this many members in a sample group with genotype calls that differs from all members of the other group.  If the sample groups share a common genotypoe call, the row will not be printed.

In --nogenotype mode the threshold is the combination of --separation-gap and --min-group-size.  If the difference in the observation ratios between the minimum-size sample groups is less than the separation gap threshold, the row will not be printed.

EXAMPLE

To sort based on the degree of difference between specific groups of samples, those groups can be defined on the command line using --sample-group/-s.  You can specify a minimum number of samples in the groups to differ.  So for example, say you have 3 wildtype (WT) replicates and you would like to see differences that all 3 WT samples have with any one of a set of 10 mutant samples.  You would do that on the command line using the sample names:

    vcfSampleCompare.pl -s "wt1 wt2 wt3" -d 3 -s "m1 m2 m3 m4 m5 m6 m7 m8 m9 m10" -d 1 input.vcf --gap-measure mean

The largest difference that the mean observation ratio of the WT samples has with 1 of the mutant samples will be at the top of the results.

END_AHELP
	     );

setDefaults(HEADER        => 1,
	    ERRLIMIT      => 3,
	    DEFRUNMODE    => 'usage',
	    DEFSDIR       => undef);

my $format_index            = 8;
my $sample_name_start_index = $format_index + 1;

my $vcf_type_id =
  addInfileOption(GETOPTKEY   => 'i',
		  REQUIRED    => 1,
		  PRIMARY     => 1,
		  DEFAULT     => undef,
		  SMRY_DESC   => 'VCF input file.',
		  DETAIL_DESC => ('VCF input file generated either by ' .
				  'freeBayes or svTyper.'),
		  FORMAT_DESC => << 'END_FORMAT'

A VCF file is a plain text, tab-delimited file.  The format is generally described here: http://bit.ly/2sulKcZ and described in detail here: http://bit.ly/2gKP5bN

However, the important parts that this script relies on are:

1. The column header line (in particular - looking for the FORMAT and sample name columns).
2. The colon-delimited codes in the FORMAT column values, specifically (for SNP data produced by freeBayes and Structural Variant data produced by SVTyper) AO (the number of reads supporting the variant), RO (the number of reads supporting the reference), and DP (the number of reads that map at or over the variant position).
3. The colon-delimited values in the sample columns that correspond to the positions defined in the FORMAT column.

The file may otherwise be a standard VCF file containing header lines preceded by '##'.  Empty lines are OK and will be printed regardless of parameters supplied to this script.  Note, the --header and --no-header flags of this script do not refer to the VCF file's header, but rather the run info header of this script.

END_FORMAT
		 );

my $vcf_oid =
  addOutfileSuffixOption(GETOPTKEY   => 'o',
			 PRIMARY     => 0,
			 DEFAULT     => undef,
			 SMRY_DESC   => 'VCF outfile suffix (appended to -i).',
			 FORMAT_DESC => ('The output file is the same format ' .
					 'as the input VCF files, except ' .
					 'sorted differently and possibly ' .
					 'filtered.'));

my $sum_oid =
  addOutfileSuffixOption(GETOPTKEY   => 'u',
			 PRIMARY     => 1,
			 DEFAULT     => undef,
			 SMRY_DESC   => ('Summary outfile suffix (appended ' .
					 'to -i).'),
			 DETAIL_DESC => ('Summary outfile suffix (appended ' .
					 'to -i).  This file can contain a ' .
					 'row for each variant row in the ' .
					 'input VCF file, and include the ' .
					 'sorting values and pairs of sample ' .
					 'groups that were identified as ' .
					 'different.  This file may ' .
					 'optionally be a filtered version ' .
					 'of the rows in the input VCF file ' .
					 '(-i).'),
			 FORMAT_DESC => << 'END_FORMAT'

Tab delimited file of variants that are sorted by and optionally filtered on degree of difference between 2 pairs of sample groups.  Sorting and filtering is based on the values in the BEST_GT_SCORE, BEST_OR_SCORE, and BEST_DP_SCORE columns.  The columns of the file are:

* CHROM - Chromosome - The chromosome on which the variant is located.
* POS - Position - The position starting from 1 where the variant is located.
* REF - Reference Value - The value the reference has in the variant position.
* ALT - Alternate Value(s) - The value(s) observed in the samples in the variant position.
* BEST_PAIR - Best Sample Group Pair ID - The sample group pair's number (numbered from left to right, as they were supplied on the command line) for the pair that resulted in the biggest difference in variant states between the sample groups.  A sub-ID (appended with a dot) is applied for each unique set of samples included in a pair.  If -s was not used to pre-define sample groups, this value will always be 0, though each row's pair of sample groups selected will be independent.
* BEST_GT_SCORE - Best Genotype Score - The maximum PAIR_GT_SCORE.  Values are between 0 and 1.  A score of 1 means that all members of both sample groups have genotype calls and there are no common genotype calls between the members of the pair of sample groups.  See `--help --extended` for an explanation  of lesser scores.
* BEST_OR_SCORE - Best Observation Ratio Score - The maximum PAIR_OR_SCORE.  Values are between 0 and 1 (when --gap-measure is "mean") or -1 and 1 (when --gap-measure is "edge").  See `--help --extended` for more details.
* BEST_DP_SCORE - Best Depth Score - The read depth score of the best sample group pair.  The read depth score of the best pair is based on the lower average read depth of the 2 sample groups in the pair.  See the usage for -x and -l to see how the score is calculated.
* PAIR_ID - Pair ID - A colon-delimited list of IDs indicating the pair of sample groups the sort and filtering is based on (numbered from left to right, as they were supplied on the command line), with a dot-appended sub-ID indicating the unique set of samples included in the pair.  Each unique set of samples gets its own ID, assigned in the order encountered.  The sub-ID is independent of the parent pair ID.
* PAIR_GT_SCORE - Pair Genotype Score - A colon-delimited list of each sample group pair's maximum GT score.
* PAIR_OR_SCORE - Pair Observation Ratio Score - A colon-delimited list of each sample group pair's maximum observation ratio score.
* PAIR_DP_SCORE - Pair Read Depth Score - A colon-delimited list of each sample group pair's read depth score.  The read depth score for each pair is based on the lower average read depth of the 2 sample groups in the pair.  See the usage for -x and -l to see how the score is calculated.
* STATES_USED_GT - Genotype Calls Used - The genotype calls used to calculate the BEST_GT_SCORE.  There will be at least 2 genotype calls separated by a semicolon.  If there are multiple genotype calls present in 1 sample group, they will be delimited with a "+".
* STATE_USED_OR - Variant State Used to Calculate Observation Ratios - The state used can be 0 (the value of the variant at the variant position in the reference), or a number indicating which of the ALT observations produced the BEST_OR_SCORE.  E.g. if the state '0' was used to compute the scores (indicating the REF state), then (by default) the average observation ratio of each group will be close to either N/N (i.e. the same as the reference) and the other group will be close to 0/N (i.e. different from the reference).
* GROUP1_SAMPLES - Sample Group 1 Members - A comma-delimited list of sample names belonging to group 1.  Lists of group 1 samples from multiple pairs of sample groups will be colon-delimited.  E.g. For 2 pairs, the value might be: "s1,s2:s6,s7".
* GROUP1_GTS - Sample Group 1 Genotype Calls - A list of comma-delimited genotype calls.  Lists of group 1 genotype calls from multiple pairs of sample groups will be colon-delimited.
* GROUP1_ORS - Sample Group 1 Observation Ratios - A list of comma-delimited observation ratios based on the variant state in STATE_USED_OR.  Lists of group 1 observation ratios from multiple pairs of sample groups will be colon-delimited.
* GROUP2_SAMPLES - Sample Group 2 Members - A comma-delimited list of sample names belonging to group 2.  Lists of group 2 samples from multiple pairs of sample groups will be colon-delimited.  E.g. For 2 pairs, the value might be: "s1,s2:s6,s7".
* GROUP2_GTS - Sample Group 2 Genotype Calls - A list of comma-delimited genotype calls.  Lists of group 2 genotype calls from multiple pairs of sample groups will be colon-delimited.
* GROUP2_ORS - Sample Group 2 Observation Ratios - A list of comma-delimited observation ratios based on the variant state in STATE_USED_OR.  Lists of group 2 observation ratios from multiple pairs of sample groups will be colon-delimited.

Example:

    #CHROM	POS	ID	REF	ALT	BEST_PAIR	BEST_GT_SCORE	BEST_OR_SCORE	BEST_DP_SCORE	PAIR_ID	PAIR_GT_SCORE	PAIR_OR_SCORE	PAIR_DP_SCORE	STATES_USED_GT	STATE_USED_OR	GROUP1_SAMPLES	GROUP1_GTS	GROUP1_ORS	GROUP2_SAMPLES	GROUP2_GTS	GROUP2_ORS
    Chromosome	6610	.	C	G	1	1	1	408	1	1	1	408	1;0	1	sample1	1	254/254	sample2,sample3	0,0	0/407,0/564
    Chromosome	10723	.	C	G	1	1	1	111	1	1	1	111	1;0	1	sample1	1	39/39	sample2,sample3	0,0	0/78,0/216
    Chromosome	10843	.	T	C	1	1	1	33	1	1	1	33	1;0	1	sample1	1	8/8	sample2,sample3	0,0	0/25,0/67
    Chromosome	10855	.	T	G	1	1	1	24	1	1	1	24	1;0	1	sample1	1	9/9	sample2,sample3	0,0	0/17,0/47
    Chromosome	10866	.	TCCTG	CCCTA	1	1	1	21	1	1	1	21	1;0	1	sample1	1	6/6	sample2,sample3	0,0	0/15,0/42
    Chromosome	10876	.	C	G	1	1	1	20	1	1	1	20	1;0	1	sample1	1	8/8	sample2,sample3	0,0	0/13,0/38
    Chromosome	10888	.	G	C	1	1	1	19	1	1	1	19	1;0	1	sample1	1	8/8	sample2,sample3	0,0	0/11,0/37

END_FORMAT
			);

my $sample_groups = [];
add2DArrayOption(GETOPTKEY   => 's|sample-group',
		 TYPE        => 'string',
		 GETOPTVAL   => $sample_groups,
		 DISPDEF     => 'any^',
		 SMRY_DESC   => ('A group of sample names for difference ' .
				 'comparisons.  ^ See --extended usage.'),
		 DETAIL_DESC => << 'END_DETAIL'

This option must be supplied an even number of times (or once* or 0 times**).  Each pair of samples groups, in order, is compared to determine the maximum difference between the groups.  For example, if you have 3 wildtype samples and 4 mutant samples, you can define these 2 groups using -s 's1 s2 s3' -s 's4 s5 s6 s7' (where 's1', 's2', and 's3' are the wildtype samples and 's4', 's5', 's6', and 's7' are mutant samples.  (All sample names must match the sample names in the VCF column headers row.)  The differences in variant states between these groups of samples will be used to sort the variants/rows of the VCF file.  See --extended --help for a description of how degree of difference is calculated.

^ If no sample groups are supplied, a default pair of samples that are the most different on any particular row will be chosen.
* If only one group is defined, the second group is assumed to be the remainder of the samples.
** If no groups are defined, groups are dynamically determined for each variant/row.  See --help --extended for details.

END_DETAIL
		);

my $group_diff_mins = [];
addArrayOption(GETOPTKEY   => 'd|min-group-size',
	       GETOPTVAL   => $group_diff_mins,
	       TYPE        => 'integer',
	       DELIMITER   => '\D+',
	       DISPDEF     => 'all*',
	       SMRY_DESC   => ('Minimum number of samples to use in a group ' .
			       'to determine difference with its partner.'),
	       DETAIL_DESC => << 'END_DETAIL'

Each sample group defined by -s is accompanied by a (minimum) number of samples in that group with which to compute the maximum difference against its partner group.  Each instance of -s should have a -d value supplied.  The order of the -d values should correspond to the order of the -s sample groups they apply to.  When -s is supplied, the default for each group is the group size, but a smaller number can bespecified.  The purpose is best shown by example.  If you have 5 mutant samples and 3 replicate wildtype samples, you may want to find variants where 1 or more mutants differ from all 3 wildtype samples, thus -d for the mutant group would be '1' and -d for the wildtype group would be '3'.  In order to produce meaningful results, one group in each pair of groups must get a value that is larger than half the group size.  See --help --extended for details on how this affects variant sorting, sample group growing, and filtering.

When -s is supplied, setting -d to 0 will automatically set the minimum group size to the number of samples in the corresponding -s sample group.

* If -s is not supplied, -d defaults to 1 for each of the 2 dynamically created sample groups.

END_DETAIL
		);

my $separation_gap = 0.7;
addOption(GETOPTKEY   => 'a|separation-gap|minimum-or-score',
	  TYPE        => 'float',
	  GETOPTVAL   => \$separation_gap,
	  DEFAULT     => $separation_gap,
	  SMRY_DESC   => ("Minimum observation ratio difference [0-1]."),
	  DETAIL_DESC => ('The difference between observation ratios (i.e. ' .
			  'allelic frequencies) of 2 sample groups (defined ' .
			  'by -s and -d) for a given variant state (e.g. a ' .
			  'SNP value of "A"), as calculated using the --gap-' .
			  'measure method, must be at least this value in ' .
			  'order for a variant to be retained (see --filter|' .
			  '--nofilter) or for a sample to be added to a ' .
			  'sample group (see --grow|--nogrow).  The ' .
			  'separation gap (or difference between observation ' .
			  'ratios) can be calculated for every variant state ' .
			  '(e.g. SNP values of "A", "T", "G", or "C" have ' .
			  'separate ratios for each sample).  The state ' .
			  'which produces the largest gap is the one that is ' .
			  'used to filter variants and add samples to sample ' .
			  'groups.  Note that if only 1 or 0 samples have ' .
			  'data, it will be filtered regardless of this ' .
			  'threshold.  Use --nofilter to retain cases of too ' .
			  'little data.  See --help --extended for more ' .
			  'details.'));

my $gap_measures = ['mean','edge'];
my $gap_measure  = $gap_measures->[0];
addOption(GETOPTKEY   => 'm|gap-measure',
	  TYPE        => 'enum',
	  ACCEPTS     => $gap_measures,
	  GETOPTVAL   => \$gap_measure,
	  DEFAULT     => $gap_measure,
	  DETAIL_DESC => << 'end_detail'

Method to measure the gap between the observation ratios (i.e. "allelic frequencies") of 2 sample groups.

Using each sample group's mean observation ratio to measure the gap between sample groups is done by taking the absolute difference of the mean observation ratio of group 1 versus group 2, resulting in a value between 0 and 1.

Using the (nearest or most overlapping) edge method results in a number between -1 and 1, where values between 0 and 1 represent the difference between the closest observation ratios (when there is no overlap) and values between -1 and 0 represent the maximum degree of overlap of the range of observation ratios.  Note, if the range of one group contains the range of another, the score is -1.

Example 1 (observation ratios [AO/DP] for SNP state "G" for 2 sample groups of size 3):

    Group1 ratios: 0.1, 0.2, 0.3
    Group2 ratios: 0.7, 0.8, 0.9
    Edge Score: 0.4
    Mean score: 0.6

Example 2 (observation ratios [AO/DP] for SNP state "G" for 2 sample groups of size 3):

    Group1 ratios: 0.1, 0.5, 0.7
    Group2 ratios: 0.3, 0.7, 0.9
    Edge Score: -0.4
    Mean score: 0.2

end_detail
	 );

my $genotype = 1;
addOption(GETOPTKEY   => 'g|genotype',
	  TYPE        => 'negbool',
	  GETOPTVAL   => \$genotype,
	  DEFAULT     => $genotype,
	  SMRY_DESC   => ("Do not use genotype calls for sorting/filtering."),
	  DETAIL_DESC => ("Do not use the genotype call (i.e. the 'GT' " .
			  'value in the FORMAT string) for sorting & ' .
			  'filtering rows, or creating/growing sample ' .
			  'groups.  Instead, use observation ratios.  See ' .
			  '--nogrow and --nofilter.  See --help --extended ' .
			  'for details.'));

my $min_gt_score = 1;
addOption(GETOPTKEY   => 't|minimum-gt-score',
	  TYPE        => 'float',
	  GETOPTVAL   => \$min_gt_score,
	  DEFAULT     => $min_gt_score,
	  ADVANCED    => 1,
	  SMRY_DESC   => ('Minimum genotype call ratio difference between ' .
			  'sample groups [0-1].'),
	  DETAIL_DESC => ('Minimum genotype call ratio difference between ' .
			  'sample groups [0-1].  This is only useful when ' .
			  'set to 1, but is provided as an advanced option ' .
			  'to allow some mixing of genotype calls between ' .
			  'sample groups and instead rely more heavily on ' .
			  'the gap between observation ratios (see -a).  The ' .
			  'genotype score, which this threshold operated on ' .
			  'is based on a metric called the "ratio of ' .
			  "resolution\".  It's best explained by example.  " .
			  'If all samples have genotype calls and comparing ' .
			  "one sample group's genotype calls with all " .
			  'genotype calls in one group differ from those ' .
			  "comparing one sample group's genotype calls with " .
			  'of the other group (see -s), comparing one sample ' .
			  "group's genotype calls with the score will be 1.  " .
			  'If each group is composed comparing one sample ' .
			  "group's genotype calls with of the same genotype " .
			  'call or even numbers of common genotype calls ' .
			  "(e.g. group 1's calls: 0,0,1,1 group 2's calls: " .
			  '0,1), the score will be 0.'));

my $filter = 1;
addOption(GETOPTKEY   => 'f|filter',
	  TYPE        => 'negbool',
	  GETOPTVAL   => \$filter,
	  DEFAULT     => $filter,
	  SMRY_DESC   => ("Do not filter variant rows."),
	  DETAIL_DESC => ('Variants/rows are filtered based on the ' .
			  'characteristics of the best sample group pair, ' .
			  'such as the size of the sample groups (see ' .
			  '--min-group-size and --grow), the depth of read ' .
			  'coverage (see --minimum-depth), and either their ' .
			  'genotype score or observation ratio score (see ' .
			  '--separation-gap).  Supply this option to not ' .
			  'filter variant rows whose best sample group pair ' .
			  'does not meet these thresholds.  See --help ' .
			  '--extended for more details.'));

my $grow = 1;
addOption(GETOPTKEY   => 'w|grow',
	  TYPE        => 'negbool',
	  GETOPTVAL   => \$grow,
	  DEFAULT     => $grow,
	  SMRY_DESC   => ('Do not add samples to sample groups beyond the ' .
			  '--min-group-size.'),
	  DETAIL_DESC => ('If the --min-group-size is less than the number ' .
			  'of samples in a group defined by --sample-group, ' .
			  'by default the script will keep adding samples to ' .
			  'the groups (from their remaining members) as long ' .
			  'as (if --nogenotype is supplied) the comparison ' .
			  'of the observation ratios (see --gap-measure) ' .
			  'between the groups is greater than -a or (if ' .
			  '--genotype is supplied) the genotype call is the ' .
			  'same as that of the current members or is ' .
			  'different from all partner group genotypes.  ' .
			  'Note, this may lower the sort order of a variant/' .
			  'row when --nogenotype is supplied.'));

my $min_depth = 4;
addOption(GETOPTKEY   => 'l|minimum-depth',
	  TYPE        => 'integer',
	  GETOPTVAL   => \$min_depth,
	  DEFAULT     => $min_depth,
	  SMRY_DESC   => ("Minimum read depth (DP)."),
	  DETAIL_DESC => << 'end_detail'

Minimum read depth (DP).  Samples whose DP value is below this threshold will not be added to sample groups (see -d) when --grow is true.  Note however that user-defined sample groups (see -s) still include samples with depths below the minimum depth, but variants/rows for which all samples in either sample group have DP scores below a minimum score based on this threshold, will be omitted from the results (when --filter is true).  The minimum DP score is calculated in the following manner:

    S_m = D_m / D_a

where:

    S_m = Minimum depth score
    D_m = Minimum depth
    D_a = Adequate depth

If you wish to only down-weight low-depth samples and include them in dynamically generated group pairs, use -x.

end_detail
	 );

my $max_depth = 20;
addOption(GETOPTKEY   => 'x|adequate-depth',
	  TYPE        => 'integer',
	  GETOPTVAL   => \$max_depth,
	  DEFAULT     => $max_depth,
	  SMRY_DESC   => ("Adequate read depth (DP)."),
	  DETAIL_DESC => << 'end_detail'

Adequate read depth (DP).  This is the depth at which all samples with greater depth are treated as equally capable at yielding confident results.  Individual samples whose DP value is below this threshold will have down-weighted depth scores (between 0 and 1).  Samples at or above this depth will have a depth score of 1.  Depth scores for pairs of sample groups are reported under BEST_DP_SCORE and PAIR_DP_SCORE (see -u).  The depth score calculated for a pair of sample groups is calculated in the following manner:

    S = MIN(SUM[i=1..n](D_i > D_a ? D_a : D_i) / (D_a * n),
            SUM[i=1..m](D_i > D_a ? D_a : D_i) / (D_a * m))

where:

    S   = Depth score
    n   = Number of samples in group 1
    n   = Number of samples in group 2
    i   = Sample number
    D_i = Depth of sample i
    D_a = Adequate depth

If you wish to filter low-depth samples, use -l.

end_detail
	 );

my $dp_weight = 100;
addOption(GETOPTKEY   => 'dp-sort-weight',
	  TYPE        => 'float',
	  GETOPTVAL   => \$dp_weight,
	  DEFAULT     => $dp_weight,
	  ADVANCED    => 1,
	  SMRY_DESC   => ('Sort weight for depth scores.'),
	  DETAIL_DESC => ('Sort weight for depth scores.  This can be any ' .
			  'positive number.  It is multiplied by the best ' .
			  'depth score (the values in the BEST_DP_SCORE ' .
			  'column) and is added to the other weighted scores ' .
			  '(BEST_OR_SCORE and BEST_GT_SCORE) to determine ' .
			  '(descending) sort order for the variant rows.  ' .
			  'All unweighted scores are a value between 0 and ' .
			  '1.'));

my $gt_weight = 10;
addOption(GETOPTKEY   => 'gt-sort-weight',
	  TYPE        => 'float',
	  GETOPTVAL   => \$gt_weight,
	  DEFAULT     => $gt_weight,
	  ADVANCED    => 1,
	  SMRY_DESC   => ('Sort weight for genotype call scores.'),
	  DETAIL_DESC => ('Sort weight for genotype call scores.  This can ' .
			  'be any positive number.  It is multiplied by the ' .
			  'best genotype call score (the values in the ' .
			  'BEST_GT_SCORE column) and is added to the other ' .
			  'weighted scores (BEST_OR_SCORE and BEST_DP_SCORE) ' .
			  'to determine (descending) sort order for the ' .
			  'variant rows.  All unweighted scores are a value ' .
			  'between 0 and 1.'));

my $or_weight = 1;
addOption(GETOPTKEY   => 'or-sort-weight',
	  TYPE        => 'float',
	  GETOPTVAL   => \$or_weight,
	  DEFAULT     => $or_weight,
	  ADVANCED    => 1,
	  SMRY_DESC   => ('Sort weight for observation ratio scores.'),
	  DETAIL_DESC => ('Sort weight for observation ratio scores.  This ' .
			  'can be any positive number.  It is multiplied by ' .
			  'the best observation ratio score (the values in ' .
			  'the BEST_GT_SCORE column) and is added to the ' .
			  'other weighted scores (BEST_OR_SCORE and ' .
			  'BEST_DP_SCORE) to determine (descending) sort ' .
			  'order for the variant rows.  All unweighted ' .
			  'observation ratio scores are a value between -1 ' .
			  'and 1.  Values less than 0 mean that there is ' .
			  'overlap between the observation ratios in each ' .
			  'sample group, which acts as a penalty.'));

processCommandLine();

#There must be an even number of sample groups (or 1)
if(scalar(@$sample_groups) % 2 && scalar(@$sample_groups) != 1)
  {
    error("There must be an even number of sample groups (or 1), but [",
	  scalar(@$sample_groups),"] were supplied.  See the usage ",
	  "description for -s for details.",
	  {DETAIL => ('Groups are submitted in pairs and the difference in ' .
		      'their average observation ratios is used for sorting, ' .
		      'filtering, and growing.  If 1 is supplied, the second ' .
		      'group is automatically populated with the remainder')});
    quit(1);
  }

#Construct default values for the group_diff_mins if they weren't all supplied
if(scalar(@$sample_groups) &&
   scalar(@$sample_groups) > scalar(@$group_diff_mins))
  {
    my $all = (scalar(@$group_diff_mins) == 0);
    foreach my $sample_group_index (0..$#{$sample_groups})
      {
	if(scalar(@$group_diff_mins) < ($sample_group_index + 1))
	  {
	    if($all || ($group_diff_mins->[0] >
			scalar(@{$sample_groups->[$sample_group_index]})))
	      {$group_diff_mins->[$sample_group_index] =
		 scalar(@{$sample_groups->[$sample_group_index]})}
	    else
	      {$group_diff_mins->[$sample_group_index] = $group_diff_mins->[0]}
	  }
      }
  }
elsif(scalar(@$sample_groups) && scalar(@$group_diff_mins))
  {
    #For each min group size
    foreach my $group_index (0..$#{$group_diff_mins})
      {
	#If the sample group exists and the min size is 0, set the min size to
	#the size of the group
	if(scalar(@$sample_groups) > $group_index &&
	   $group_diff_mins->[$group_index] == 0)
	  {$group_diff_mins->[$group_index] =
	     scalar(@{$sample_groups->[$group_index]})}
      }
  }


if(scalar(@$group_diff_mins) && scalar(@$sample_groups))
  {
    #There must be an equal number of group diff mins
    if((scalar(@$sample_groups) > 2 &&
	scalar(@$group_diff_mins) != scalar(@$sample_groups)) ||
       (scalar(@$sample_groups) <= 2 && scalar(@$group_diff_mins) > 2))
      {
	error("-d must be supplied 0, 1, 2, or the same number of times as ",
	      "-s.");
	quit(2);
      }
    #The values of the group diff mins must be less than or equal to the
    #corresponding group sizes
    elsif(scalar(@$group_diff_mins) <= scalar(@$sample_groups) &&
	  scalar(grep {$group_diff_mins->[$_] < 1 ||
			 $group_diff_mins->[$_] >
			   scalar(@{$sample_groups->[$_]})}
		 (0..$#{$group_diff_mins})))
      {
	error("The min group size (-d) [",join(',',@$group_diff_mins),
	      "] must be a positive value greater than 0 and less than or ",
	      "equal to the number of members in the corresponding sample ",
	      "group [",join(',',map {scalar(@$_)} @$sample_groups),"].  ",
	      "Unable to proceed.");
	quit(3);
      }
  }

#If this is the special case of 1 group (and possibly 2 min diff sizes)
if(scalar(@$sample_groups) == 1)
  {
    #If there are 2 min diff sizes, the first must represent the majority of its
    #group
    if(scalar(@$group_diff_mins) >= 1 &&
       $group_diff_mins->[0] <= (scalar(@{$sample_groups->[0]}) / 2))
      {
	error("When 1 sample group is supplied (implying that the second ",
	      "sample group is the remainder of the samples) and a min group ",
	      "size is supplied, the first size must represent a majority of ",
	      "the group size.");
	quit(4);
      }
  }
#NOTE: One of the group_diff_mins in each pair must represent a majority of the
#corresponding group
elsif(scalar(@$sample_groups) &&
      scalar(grep {($group_diff_mins->[$_] >
		    (scalar(@{$sample_groups->[$_]}) / 2)) ||
		      ($group_diff_mins->[$_ + 1] >
		       (scalar(@{$sample_groups->[$_ + 1]}) / 2))}
	     grep {$_ % 2 == 0} (0..$#{$sample_groups})) == 0)
  {
    error("One of each pair of group diff mins (-d) must represent a ",
	  "majority of the number of members in its corresponding sample ",
	  "group.",
	  {DETAIL => "One group must serve as an unambiguous reference " .
	   "genotype.  It can be a single sample or a set of replicate " .
	   "samples.  This makes the results more interpretable."});
    quit(5);
  }

my $dynamic_group_creation = (scalar(@$sample_groups) == 0);

if($gap_measure eq 'mean' && ($separation_gap < 0 || $separation_gap > 1))
  {
    error("Invalid value for -a [$separation_gap].  Must be between 0 and 1 ",
	  "(inclusive) when -m is 'mean'.");
    quit(6);
  }
elsif($gap_measure eq 'edge' && ($separation_gap < -1 || $separation_gap > 1))
  {
    error("Invalid value for -a [$separation_gap].  Must be between -1 and 1 ",
	  "(inclusive) when -m is 'edge'.");
    quit(7);
  }
elsif($dynamic_group_creation && $separation_gap <= 0)
  {
    error("The separation gap (--separation-gap/-a) [$separation_gap] cannot ",
	  "be less than or equal to 0 when no sample groups are defined (see ",
	  "-s).",
	  {DETAIL =>
	   join('',('A score less than 0 is not possible with dynamic sample ',
		    'group creation and a score of 0 would mean that the ',
		    'genotypes/allelic frequencies of all samples (with data) ',
		    'would be the same.  If you just want to not filter any ',
		    'data, use --nofilter.  Note, you can use --force to ',
		    'force -a to be 0 or less.'))});
    quit(8);
  }

if($max_depth < 1)
  {
    error("Adequate depth (-x) [$max_depth] must be an integer greater than ",
	  "0.");
    quit(9);
  }

if($min_depth < 0 || !isUnsignedInteger($min_depth))
  {
    error("Minimum depth (-l) [$min_depth] must be an unsigned integer.");
    quit(9);
  }

if($max_depth < $min_depth)
  {
    error("Adequate depth (-x) [$max_depth] cannot be less than minimum depth ",
	  "(-l) [$min_depth].");
    quit(10);
  }

while(nextFileCombo())
  {
    my $inputFile  = getInfile();
    my $outputFile = getOutfile($sum_oid);
    my $vcfoutFile = getOutfile($vcf_oid);

    openIn(*IN,$inputFile)     || next;

    my $line_num          = 0;
    my @samples           = ();
    my $orig_sample_order = {};
    my $data_line         = 0;
    my $outputs           = {HEADER_LINES  => '',
			     COMMENT_LINES => '',
			     ROW_DATA      => []};
    my $pair_hash         = {};

    while(getLine(*IN))
      {
	$line_num++;

	#If this is a header line that is not the (first) column header line
	if(/^##/)
	  {
	    if(defined($vcfoutFile) && /^#/)
	      {$outputs->{HEADER_LINES} .= $_}
	    next;
	  }
	elsif(scalar(@samples) && /^#/)
	  {
	    if(defined($vcfoutFile) && /^#/)
	      {$outputs->{COMMENT_LINES} .= $_}
	    next;
	  }
	elsif(/^\s*$/)
	  {next}

	chomp;
	my @cols = split(/\t/,$_,-1);

	#If this is the (first) column header line
	if(/^#[^#].*\t/ && scalar(@samples) == 0)
	  {
	    #Get the index of the FORMAT column - we will assume that the
	    #sample columns start immediately after and go to the end
	    if(/\tFORMAT\t/)
	      {
		#Assuming only 1 FORMAT column header
		$format_index = (grep {$cols[$_] eq 'FORMAT'} (0..$#cols))[0];
		$sample_name_start_index = $format_index + 1;
	      }
	    else
	      {
		warning("FORMAT column header not found on column header ",
			"line.  Using default expected FORMAT column number [",
			($format_index + 1),"] and sample column start ",
			"number [",($sample_name_start_index + 1),"].");
	      }

	    #If -s was supplied, the sample names in the column header are
	    #necessary - otherwise, we can assume that the header is just
	    #malformed and that the samples are where we would otherwise expect
	    #them to be in a standard VCF file (as produced by FreeBayes).
	    if(scalar(@samples) &&
	       scalar(@cols) < ($sample_name_start_index + 1))
	      {
		error("No columns for sample names were found on the ",
		      "column header line: [$_].  Unable to finish ",
		      "processing file [$inputFile].",
		      {DETAIL => "Sample names in the column header are " .
		       "used to identify sample columns for use with the -s " .
		       "and -d parameters, and to find the number of " .
		       "supporting read and total reads for each record.  " .
		       "If your column header line is malformed, but the " .
		       "data is there and you do not supply -s or -d, you " .
		       "will still be able to proceed using the default " .
		       "FORMAT column number [",($format_index + 1),"] and " .
		       "sample column start number [",
		       ($sample_name_start_index + 1),"]."});

		last;
	      }

	    @samples = @cols[$sample_name_start_index..$#cols];
	    s/#//;

	    if(scalar(@samples) < 2)
	      {
		error("A column header line with more than 1 sample name ",
		      "after the FORMAT column is required.  Skipping file ",
		      "[$inputFile].",
		      {DETAIL => ('The purpose of this script is to compare ' .
				  'samples, which requires more than 1 ' .
				  'sample be present in the file.')});
		last;
	      }
	    if(scalar(grep {$_ eq ''} @samples))
	      {
		error("Empty sample names encountered on column header row ",
		      "after the FORMAT column.  Skipping file [$inputFile].",
		      {DETAIL => ('Sample names are used in the output ' .
				  'format of this script for identification ' .
				  'of sample groups, thus they must all have ' .
				  'values.')});
		last;
	      }

	    #Validate the sample names in the groups
	    if(scalar(@$sample_groups))
	      {unless(validateSampleGroupNames(\@samples,$sample_groups))
		 {quit(11)}}

	    #Handle a special case where auto-group creation is allowed
	    if(scalar(@$sample_groups) == 1)
	      {
		#Validate that there are enough samples to create a second group
		if(scalar(@{$sample_groups->[0]}) >= scalar(@samples))
		  {
		    error("Not enough samples [",scalar(@samples),"] to auto-",
			  "create second sample group (-s), given the first ",
			  "sample group size of [",
			  scalar(@{$sample_groups->[0]}),"].");
		    quit(12);
		  }

		#Create the second group
		push(@$sample_groups,
		     [grep {my $n=$_;
			    scalar(grep {$_ eq $n} @{$sample_groups->[0]}) == 0}
		      @samples]);

		#Validate any existing group diff min
		if(scalar(@$group_diff_mins) == scalar(@$sample_groups))
		  {
		    if($group_diff_mins->[1] > scalar(@{$sample_groups->[1]}) ||
		       $group_diff_mins->[1] < 1)
		      {
			error("Invalid min group size (-d) [",
			      $group_diff_mins->[1],"] for sample group of ",
			      "size [",scalar(@{$sample_groups->[1]}),"].");
			quit(13);
		      }
		  }
		#Add a new group diff min
		else
		  {push(@$group_diff_mins,scalar(@{$sample_groups->[1]}))}
	      }

	    #If there's not at least 2 min group sizes
	    if(scalar(@$group_diff_mins) < 2)
	      {
		#If there's 1 min group size, compute the size of the second one
		if(scalar(@$group_diff_mins))
		  {push(@$group_diff_mins,
			scalar(@samples) - $group_diff_mins->[0])}
		else
		  {push(@$group_diff_mins,1,1)}
	      }

	    debug("Min group sizes: [",join(',',@$group_diff_mins),"].",
		  {LEVEL => 3});

	    #Print the new header
	    $outputs->{HEADER_LINES} .= "#$_\n";

	    next;
	  }
	elsif(scalar(@samples) == 0)
	  {
	    warning("Column header line not found before data.  Using ",
		    "default expected FORMAT column number [",
		    ($format_index + 1),"] and sample column start number [",
		    ($sample_name_start_index + 1),"].");
	  }

	if(scalar(@cols) < ($sample_name_start_index + 1))
	  {
	    error("Sample data was not found on line: [$line_num] of VCF ",
		  "file [$inputFile].  Skipping line.",
		  {DETAIL => "Sample names in the column header are " .
		   "used to identify sample columns for use with the -s " .
		   "and -d parameters, and to find the number of " .
		   "supporting read and total reads for each record.  " .
		   "If your column header line is malformed, but the " .
		   "data is there and you do not supply -s or -d, you " .
		   "will still be able to proceed using the default " .
		   "FORMAT column number [",($format_index + 1),"] and " .
		   "sample column start number [",
		   ($sample_name_start_index + 1),"]."});

	    next;
	  }

	$data_line++;

	my $format_str = $cols[$format_index];
	my(@data)      = @cols[$sample_name_start_index..$#cols];

	debug("FORMAT string for data record [$cols[0]:$cols[1]] on line ",
	      "[$data_line]: [$format_str].");
	debug({LEVEL => 2},"Record [$data_line]: [$_].");

	#Determine the subindex of each piece of sample data based on the
	#FORMAT string by creating a hash
	my $format_subindex = 0;
	my $format_key_tosubindex = {};
	foreach my $key (split(/:/,$format_str,-1))
	  {$format_key_tosubindex->{$key} = $format_subindex++}

	if($genotype && !exists($format_key_tosubindex->{GT}))
	  {
	    error("Line [$line_num] does not contain the required tag [GT] ",
		  "(for running in --genotype mode) in the FORMAT column.  ",
		  "Skipping.");
	    next;
	  }
	elsif(!$genotype && scalar(grep {!exists($format_key_tosubindex->{$_})}
				   ('AO','RO','DP')))
	  {
	    error("Line [$line_num] does not contain the required tags [",
		  join(',',grep {!exists($format_key_tosubindex->{$_})}
		       ('AO','RO','DP')),
		  "] (for running in --nogenotype mode) in the FORMAT ",
		  "column.  Skipping.");
	    next;
	  }

	#Parse the sample info from all the sample columns
	my $sample_info = {};
	foreach my $sample_index (0..$#samples)
	  {
	    #If there is no data for this sample (i.e. no reads mapped over the
	    #position of this variant)
	    if($data[$sample_index] eq '.')
	      {
		#Create a bogus record so GT, DP, RO, & AO can be set to ./0
		$data[$sample_index] =
		  '.:' . '0:'x(scalar(keys(%$format_key_tosubindex)) - 1);
		chop($data[$sample_index]);
	      }

	    #Get the sample name for this sample column
	    my $sample = $samples[$sample_index];

	    #Get the data specific to this sample
	    my @d = split(/:/,$data[$sample_index],-1);

	    debug("Data for sample [$sample]: [",join(':',@d),"].",
		  {LEVEL => 3});

	    #Create easy access to the sample info by creating a hash like:
	    #sample_info->{$samplename}->{GT} = value
	    $sample_info->{$sample} =
	      {map {$_ => ($d[$format_key_tosubindex->{$_}] eq '.' &&
			   $_ ne 'GT' ? 0 : $d[$format_key_tosubindex->{$_}])}
	       keys(%$format_key_tosubindex)};
	    $orig_sample_order->{$sample} = $sample_index;

	    #Let's add ALT, because if data was merged from multiple runs,
	    #different samples will have comma-delimited AO values while others
	    #will have a single '.' even though there may be multiple ALT values
	    $sample_info->{$sample}->{ALT} = $cols[4];
	  }

	#Quick error check.  There must be either 0 or scalar(@$group_diff_mins)
	#sample groups
	if(scalar(@$sample_groups) != 0 &&
	   scalar(@$sample_groups) != scalar(@$group_diff_mins))
	  {
	    error("Invalid number of sample groups: [",scalar(@$sample_groups),
		  "].  Must be the same as the number of minimum group sizes ",
		  "(see -d).  Unable to proceed.");
	    quit(14);
	  }

	my @tmp_sample_groups = @$sample_groups;
	#If the sample groups have not been created, initialize them
	if(scalar(@tmp_sample_groups) == 0)
	  {@tmp_sample_groups =
	     createDynamicMaxSampleGroupPair($sample_info,$group_diff_mins)}

	debug("Sample groups this row: [(",
	      join('),(',map {my $a = $_;defined($a) ?
				join(',',map {defined($_) ? $_ : 'undef'} @$a) :
				  'undef'} @tmp_sample_groups),
	      ")].");

	if(scalar(@tmp_sample_groups) == 0 ||
	   scalar(grep {scalar(@$_) == 0} @tmp_sample_groups))
	  {
	    error("No sample groups could be determined for the variant on ",
		  "line [$line_num] of file [$inputFile].",
		  {DETAIL => ('Sample groups are automatically determined ' .
			      'based on the ' .
			      ($genotype ? 'genotype call (GT)' : 'allelic ' .
			       'frequencies (AO/DP and RO/DP observation ' .
			       'ratio(s))') . '.  If no data (e.g. ' .
			      ($genotype ? 'GT is "."' : 'DP is 0') . ') in ' .
			      'all of the samples, they cannot be put into ' .
			      'sample groups.')});
	    next;
	  }

	my $anything_passed = 0;
	my $pair_num        = 0;
	my $rank_data       = [];
	my $best_gt_score   = -2;
	my $best_or_score   = -2;
	my $best_dp_score   = 0;
	my $best_pair       = '.';
	foreach my $pair_index (grep {$_ % 2 == 0} (0..$#tmp_sample_groups))
	  {
	    if($dynamic_group_creation)
	      {$pair_num = 0}
	    else
	      {$pair_num++}

	    my $set1     = [@{$tmp_sample_groups[$pair_index]}];
	    my $set1_min = $group_diff_mins->[$pair_index];
	    my $set2     = [@{$tmp_sample_groups[$pair_index + 1]}];
	    my $set2_min = $group_diff_mins->[$pair_index + 1];

	    debug("$_\nSET1: [",join(',',@$set1),"] SET1MIN: $set1_min ",
		  "SET2: [",join(',',@$set2),"] SET2MIN: $set2_min",
		  {LEVEL => 2});

	    my($min_group1,$min_group2,$real_remainders1,$real_remainders2,
	       $leftright_case) =
	      createStaticMinSampleGroupPair($set1,$set1_min,
					     $set2,$set2_min,
					     $sample_info);

	    debug("Testing groups for $cols[0] $cols[1] [",
		  (defined($min_group1) ?
		   join(',',map {defined($_) ? $_ : 'undef'} @$min_group1) :
		   'undef array'),"] vs [",
		  (defined($min_group2) ?
		   join(',',map {defined($_) ? $_ : 'undef'} @$min_group2) :
		   'undef array'),"] with remainders [@$real_remainders1] and ",
		  "[@$real_remainders2] and left/right case: [$leftright_case",
		  "].\nUsing original set1 [",
		  join(',',map {defined($_) ? $_ : 'undef'} @$set1),
		  "] vs set2 [",
		  join(',',map {defined($_) ? $_ : 'undef'} @$set2),"].");

	    #The min group is allowed to have samples under the minimum depth,
	    #but the group depth average must be above the minimum depth
	    #threshold
	    if(!$filter || sampleGroupPairPasses($min_group1,$min_group2,
						 $sample_info,1))
	      {
		$anything_passed++;

		if(scalar(@$min_group1) < scalar(@$set1) ||
		   scalar(@$min_group2) < scalar(@$set2))
		  {growAPair($min_group1,$min_group2,
			     $real_remainders1,$real_remainders2,
			     $leftright_case,$sample_info)}

		imposeOrigSampleOrder($min_group1,$orig_sample_order);
		imposeOrigSampleOrder($min_group2,$orig_sample_order);
		#If the sample groups were created dynamically
		if(scalar(@$sample_groups) == 0)
		  {imposeGroupOrder($min_group1,$min_group2,$orig_sample_order)}

		my $scoring_data = getBestScoringData($min_group1,
						      $min_group2,
						      $sample_info);

		my $sub_pair_num = '';
		#If any score is greater than the lowest score possible, assign
		#a sub-pair number.  We don't want to assign IDs to meaningless
		#pairs that were forcibly & arbitrarily created.
		if($scoring_data->{GT_SCORE} > 0 ||
		   (($dynamic_group_creation &&
		     $scoring_data->{OR_SCORE} > 0) ||
		    (!$dynamic_group_creation &&
		     $scoring_data->{OR_SCORE} > -1)) ||
		   $scoring_data->{DP_SCORE} > 0)
		  {$sub_pair_num = '.' . getSubPairNum($min_group1,
						       $min_group2,
						       $pair_hash)}

		debug("Group 1: [@$min_group1] Group 2: [@$min_group2]\n",
		      "GT Score: $scoring_data->{GT_SCORE}\n",
		      "OR Score: $scoring_data->{OR_SCORE}\n",
		      "DP Score: $scoring_data->{DP_SCORE}");

		if($genotype)
		  {
		    if($scoring_data->{GT_SCORE} > $best_gt_score ||
		       ($scoring_data->{GT_SCORE} == $best_gt_score &&
		        $scoring_data->{OR_SCORE} > $best_or_score))
		      {
			$best_gt_score = $scoring_data->{GT_SCORE};
			$best_or_score = $scoring_data->{OR_SCORE};
			$best_dp_score = $scoring_data->{DP_SCORE};
			$best_pair     = "$pair_num$sub_pair_num";
		      }
		  }
		else
		  {
		    if($scoring_data->{OR_SCORE} > $best_or_score ||
		       ($scoring_data->{OR_SCORE} == $best_or_score &&
		        $scoring_data->{GT_SCORE} > $best_gt_score))
		      {
			$best_gt_score = $scoring_data->{GT_SCORE};
			$best_or_score = $scoring_data->{OR_SCORE};
			$best_dp_score = $scoring_data->{DP_SCORE};
			$best_pair     = "$pair_num$sub_pair_num";
		      }
		  }

		push(@$rank_data,
		     {PAIR_ID    => "$pair_num$sub_pair_num",      #float-like

		      SAMPLES1   => $min_group1,                    #array rf
		      SAMPLES2   => $min_group2,                    #array rf

		      DP_SCORE   => $scoring_data->{DP_SCORE},      #dec

		      GT_SCORE   => $scoring_data->{GT_SCORE},      #dec
		      GT_STATE   => $scoring_data->{GT_STATE},      #str
		      GROUP1_GTS => $scoring_data->{GROUP1_GTS},    #array rf
		      GROUP2_GTS => $scoring_data->{GROUP2_GTS},    #dec

		      OR_SCORE   => $scoring_data->{OR_SCORE},      #dec
		      OR_STATE   => $scoring_data->{OR_STATE},      #str
		      GROUP1_ORS => $scoring_data->{GROUP1_ORS},    #array rf
		      GROUP2_ORS => $scoring_data->{GROUP2_ORS}});  #array rf
	      }
	  }

	if($anything_passed)
	  {
	    push(@{$outputs->{ROW_DATA}},
		 {VCF_LINE      => "$_\n",
		  CHROM         => $cols[0],
		  POS           => $cols[1],
		  ID            => $cols[2],
		  REF           => $cols[3],
		  ALT           => $cols[4],
		  BEST_PAIR     => $best_pair,
		  BEST_GT_SCORE => $best_gt_score,
		  BEST_OR_SCORE => $best_or_score,
		  BEST_DP_SCORE => $best_dp_score,
		  RANK_DATA     => $rank_data});
	  }
      }

    closeIn(*IN);

    openOut(*OUT,$outputFile);
    openOut(HANDLE => *VCFO,
	    FILE   => $vcfoutFile,
	    HEADER => 0,
	    SELECT => 0);

    if(defined($vcfoutFile))
      {print VCFO ($outputs->{HEADER_LINES})}

    print OUT ("#CHROM\tPOS\tID\tREF\tALT\tBEST_PAIR\tBEST_GT_SCORE\t",
	       "BEST_OR_SCORE\tBEST_DP_SCORE\tPAIR_ID\tPAIR_GT_SCORE\t",
	       "PAIR_OR_SCORE\tPAIR_DP_SCORE\tSTATES_USED_GT\tSTATES_USED_OR\t",
	       "GROUP1_SAMPLES\tGROUP1_GTS\tGROUP1_ORS\tGROUP2_SAMPLES\t",
	       "GROUP2_GTS\tGROUP2_ORS\n");

    if(scalar(@{$outputs->{ROW_DATA}}))
      {
	my($prim_rank,$sec_rank) = ($genotype ?
				    ('BEST_GT_SCORE','BEST_OR_SCORE') :
				    ('BEST_OR_SCORE','BEST_GT_SCORE'));
	foreach my $ordered_rec
	  (sort {($b->{BEST_DP_SCORE} * $dp_weight +
		  ($genotype ? $b->{BEST_GT_SCORE} * $gt_weight : 0) +
		  $b->{BEST_OR_SCORE} * $or_weight) <=>
		    ($a->{BEST_DP_SCORE} * $dp_weight +
		     ($genotype ? $a->{BEST_GT_SCORE} * $gt_weight : 0) +
		     $a->{BEST_OR_SCORE} * $or_weight) ||
		       $a->{CHROM} cmp $b->{CHROM} || $a->{POS} <=> $b->{POS}}
	   @{$outputs->{ROW_DATA}})
	  {
	    #Print the VCF output
	    if(defined($vcfoutFile))
	      {print VCFO ($ordered_rec->{VCF_LINE})}

	    #Code for debugging
	    my $teststate =
	      join(':',map {$_->{GT_STATE}} @{$ordered_rec->{RANK_DATA}});
	    if($teststate =~ /\d/ && $ordered_rec->{BEST_DP_SCORE} == 0)
	      {warning("BEST_DP_SCORE of 0 when state has a value: ",
		       "[$teststate].")}

	    #Print the rank info
	    print OUT (join("\t",($ordered_rec->{CHROM},$ordered_rec->{POS},
				  $ordered_rec->{ID},$ordered_rec->{REF},
				  $ordered_rec->{ALT},$ordered_rec->{BEST_PAIR},
				  sigdec($ordered_rec->{BEST_GT_SCORE},4),
				  sigdec($ordered_rec->{BEST_OR_SCORE},4),
				  sigdec($ordered_rec->{BEST_DP_SCORE},4))),
		       "\t",

		       #Next column's a colon-delimited list of passing rule 
		       #numbers
		       join(':',map {$_->{PAIR_ID}}
			    @{$ordered_rec->{RANK_DATA}}),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #genotype score
		       join(':',map {sigdec($_->{GT_SCORE},4)}
			    @{$ordered_rec->{RANK_DATA}}),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #observation ratio score
		       join(':',map {sigdec($_->{OR_SCORE},4)}
			    @{$ordered_rec->{RANK_DATA}}),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #sub-score (which is the minimum DP (read depth))
		       join(':',map {sigdec($_->{DP_SCORE},4)}
			    @{$ordered_rec->{RANK_DATA}}),"\t",

		       #Next column's a colon-delimited list of each rule's
		       #genotype state, which is composed of 2 lists
		       #of unique genotype calls in sample groups 1 & 2.  Calls
		       #are delimited by "+" and groups are delimited by ";"
		       join(':',map {$_->{GT_STATE}}
			    @{$ordered_rec->{RANK_DATA}}),"\t",

		       #Next column's the variant state used to score the
		       #difference in observation ratios.
		       join(':',map {$_->{OR_STATE}}
			    @{$ordered_rec->{RANK_DATA}}),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of samples in group 1
		       join(':',(map {join(',',@{$_->{SAMPLES1}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of genotype calls in group 1
		       join(':',(map {join(',',@{$_->{GROUP1_GTS}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of observation ratios in group 1
		       join(':',(map {join(',',@{$_->{GROUP1_ORS}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of samples in group 2
		       join(':',(map {join(',',@{$_->{SAMPLES2}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of genotype calls in group 2
		       join(':',(map {join(',',@{$_->{GROUP2_GTS}})}
				 @{$ordered_rec->{RANK_DATA}})),"\t",

		       #Next column is a colon-delimited list of each rule's
		       #comma-delimited list of observation ratios in group 2
		       join(':',(map {join(',',@{$_->{GROUP2_ORS}})}
				 @{$ordered_rec->{RANK_DATA}})),"\n");
	  }
      }

    if(defined($vcfoutFile))
      {print VCFO ($outputs->{COMMENT_LINES})}

    closeOut(*VCFO);
    closeOut(*OUT);
  }


#This orders the referenced array by the index values saved in the
#orig_sample_order hash
sub imposeOrigSampleOrder
  {
    my $samples           = $_[0];
    my $orig_sample_order = $_[1];

    @$samples =
      sort {$orig_sample_order->{$a} <=> $orig_sample_order->{$b}} @$samples;
  }

#This sub simply swaps the groups if their first members are in reverse order
#relative to the original overall sample order.  The intent is just to make it
#possible to better compare scoring methods.
#WARNING: Assumes imposeOrigSampleOrder has been called on each group
sub imposeGroupOrder
  {
    my $group1            = $_[0];
    my $group2            = $_[1];
    my $orig_sample_order = $_[2];

    #If, based on the original; order, the first item in group 1 occurs after
    #the first item in group 2, swap the groups
    if($orig_sample_order->{$group1->[0]} > $orig_sample_order->{$group2->[0]})
      {
	my @holder = @$group1;
	@$group1 = @$group2;
	@$group2 = @holder;
      }
  }

#If one or the other value is zero, sort by their values, otherwise return 0 to
#allow the sort to be based on the next thing
sub compareWhenZero
  {
    my $left  = $_[0];
    my $right = $_[1];

    if($left == 0 || $right == 0)
      {return($left <=> $right)}

    return(0);
  }

#Globals used: $genotype, $min_depth, $max_depth
sub growAPair
  {
    my $min_group1       = $_[0];
    my $min_group2       = $_[1];
    my $real_remainders1 = $_[2];
    my $real_remainders2 = $_[3];
    my $leftright_case   = $_[4]; #Whether group 1 should grow from the left and
                                  #2 from the right or vice versa
    my $sample_info      = $_[5];

    return(undef) if(!$grow);

    my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
    my($something_added);

    #The following logic in deciding which group to grow at each iteration is
    #only useful for user-defined sample groups.  Dynamically created sample
    #groups do need to be grown, but their larger groups have already been
    #separated up in the best way possible.  Thus, this could be done more
    #efficiently if I didn't compare scores at this step for dynamically created
    #groups and rather just pushed the remainders on without testing.

    $something_added = 1;
    while($something_added &&
	  (scalar(@$real_remainders1) || scalar(@$real_remainders2)))
      {
	my($gt_score1,$gt_score2,$or_score1,$or_score2,
	   $next_sample1,$next_sample2,$scoring_data);
	$something_added = 0;

	my $initial_state_passes = sampleGroupPairPasses($min_group1,
							 $min_group2,
							 $sample_info,
							 1);
	my $initial_score = getBestScoringData($min_group1,
					       $min_group2,
					       $sample_info);

	#If there are still un-added samples in sample group 1
	if(scalar(@$real_remainders1))
	  {
	    $next_sample1 = ($leftright_case ?
			     $real_remainders1->[0] :
			     $real_remainders1->[-1]);
	    $scoring_data = getBestScoringData([@$min_group1,$next_sample1],
					       $min_group2,
					       $sample_info);

	    if(#If the initial state is passing, the depth is at least the
	       #minimum, and the proposed addition passes as well
	       ($initial_state_passes &&
		$expanded_sample_info->{$next_sample1}->{DP} >= $min_depth &&
		sampleGroupPairPasses([@$min_group1,$next_sample1],
				      $min_group2,$sample_info,0)) ||

	       #Or if the initial state is NOT passing, but we're not filtering,
	       #and the score improves or stays the same.  (The goal is to
	       #output the best failing pair when there will be no filtering.)
	       (!$initial_state_passes && !$filter &&
	        (($genotype &&
		  $scoring_data->{GT_SCORE} >= $initial_score->{GT_SCORE}) ||
		 (!$genotype &&
		  $scoring_data->{OR_SCORE} >= $initial_score->{OR_SCORE}))))
	      {
		$something_added = 1;
		$gt_score1 = $scoring_data->{GT_SCORE};
		$or_score1 = $scoring_data->{OR_SCORE};
	      }
	  }

	#If there are still un-added samples in sample group 2
	if(scalar(@$real_remainders2))
	  {
	    $next_sample2 = ($leftright_case ?
			     $real_remainders2->[-1] :
			     $real_remainders2->[0]);
	    $scoring_data = getBestScoringData($min_group1,
					       [@$min_group2,$next_sample2],
					       $sample_info);

	    if(#If the initial state is passing, the depth is at least the
	       #minimum, and the proposed addition passes as well
	       ($initial_state_passes &&
		$expanded_sample_info->{$next_sample2}->{DP} >= $min_depth &&
		sampleGroupPairPasses($min_group1,
				      [@$min_group2,$next_sample2],
				      $sample_info,0)) ||

	       #Or if the initial state is NOT passing, but we're not filtering,
	       #and the score improves or stays the same.  (The goal is to
	       #output the best failing pair when there will be no filtering.)
	       (!$initial_state_passes && !$filter &&
	        (($genotype &&
		  $scoring_data->{GT_SCORE} >= $initial_score->{GT_SCORE}) ||
		 (!$genotype &&
		  $scoring_data->{OR_SCORE} >= $initial_score->{OR_SCORE}))))
	      {
		$something_added = 1;
		$gt_score2 = $scoring_data->{GT_SCORE};
		$or_score2 = $scoring_data->{OR_SCORE};
	      }
	  }

	#If there was a passing sample added to one of the sample groups,
	#decide which one created a better separation
	if($something_added)
	  {
	    if($genotype)
	      {
		if(defined($gt_score1) && defined($gt_score2))
		  {
		    if($gt_score1 > $gt_score2 ||
		       ($gt_score1 == $gt_score2 &&
		        $or_score1 >= $or_score2))
		      {
			push(@$min_group1,$next_sample1);
			($leftright_case ?
			 shift(@$real_remainders1) :
			 pop(@$real_remainders1));
		      }
		    elsif($gt_score1 < $gt_score2 ||
			  ($gt_score1 == $gt_score2 &&
			   $or_score1 < $or_score2))
		      {
			push(@$min_group2,$next_sample2);
			($leftright_case ?
			 pop(@$real_remainders2) :
			 shift(@$real_remainders2));
		      }
		  }
		elsif(defined($gt_score1))
		  {
		    push(@$min_group1,$next_sample1);
		    ($leftright_case ?
		     shift(@$real_remainders1) :
		     pop(@$real_remainders1));
		  }
		elsif(defined($gt_score2))
		  {
		    push(@$min_group2,$next_sample2);
		    ($leftright_case ?
		     pop(@$real_remainders2) :
		     shift(@$real_remainders2));
		  }
	      }
	    else
	      {
		if(defined($or_score1) && defined($or_score2))
		  {
		    if($or_score1 > $or_score2 ||
		       ($or_score1 == $or_score2 &&
		        $gt_score1 >= $gt_score2))
		      {
			push(@$min_group1,$next_sample1);
			($leftright_case ?
			 shift(@$real_remainders1) :
			 pop(@$real_remainders1));
		      }
		    elsif($or_score1 < $or_score2 ||
			  ($or_score1 == $or_score2 &&
			   $gt_score1 < $gt_score2))
		      {
			push(@$min_group2,$next_sample2);
			($leftright_case ?
			 pop(@$real_remainders2) :
			 shift(@$real_remainders2));
		      }
		  }
		elsif(defined($or_score1))
		  {
		    push(@$min_group1,$next_sample1);
		    ($leftright_case ?
		     shift(@$real_remainders1) :
		     pop(@$real_remainders1));
		  }
		elsif(defined($or_score2))
		  {
		    push(@$min_group2,$next_sample2);
		    ($leftright_case ?
		     pop(@$real_remainders2) :
		     shift(@$real_remainders2));
		  }
	      }
	  }
      }
  }


sub createStaticMinSampleGroupPair
  {
    my $max_group1  = $_[0];
    my $min_size1   = $_[1];
    my $max_group2  = $_[2];
    my $min_size2   = $_[3];
    my $sample_info = $_[4];

    my $min_group1      = [];
    my $min_group2      = [];
    my $real_remainder1 = []; #Holds remaining samples that have observations
    my $real_remainder2 = [];
    my $case_leftright  = 1;  #Whether we added to 1 from the left and 2 / right

    ##
    ## The following code differs from that in createDynamicMaxSampleGroupPair
    ## because this version takes a single pair of sample groups and creates a
    ## minimum group out of each whereas createDynamicMaxSampleGroupPair takes a
    ## list of pair sizes and builds maximum sample groups from a single sample
    ## list
    ##

    if($genotype)
      {
	##
	## Figure out which min group of 2 possibilities is better
	##

	#Determine the overall genotype counts
	my $genotype_counts = {};
	foreach my $sample (keys(%$sample_info))
	  {$genotype_counts->{$sample_info->{$sample}->{GT}}++}

	#Establish the ordering of the samples of max group 1 by genotype
	#abundance
	my @ordered_samples_real1 =
	  sort {$genotype_counts->{$sample_info->{$b}->{GT}} <=>
		  $genotype_counts->{$sample_info->{$a}->{GT}} ||
		    $sample_info->{$a}->{GT} cmp $sample_info->{$b}->{GT}}
	    grep {$sample_info->{$_}->{GT} !~ /\./} @$max_group1;
	my @nocalls1 = grep {$sample_info->{$_}->{GT} =~ /\./} @$max_group1;

	#Establish the ordering of the samples of max group 2 by genotype
	#abundance
	my @ordered_samples_real2 =
	  sort {$genotype_counts->{$sample_info->{$b}->{GT}} <=>
		  $genotype_counts->{$sample_info->{$a}->{GT}} ||
		    $sample_info->{$a}->{GT} cmp $sample_info->{$b}->{GT}}
	    grep {$sample_info->{$_}->{GT} !~ /\./} @$max_group2;
	my @nocalls2 = grep {$sample_info->{$_}->{GT} =~ /\./} @$max_group2;

	#Case 1: left of group 1 versus right of group 2
	my @ordered_samples_real1_tmp = @ordered_samples_real1;
	my @nocalls1_tmp              = @nocalls1;
	my @ordered_samples_real2_tmp = @ordered_samples_real2;
	my @nocalls2_tmp              = @nocalls2;
	my $min_group1_case1          = [];
	my $min_group2_case1          = [];
	my $real_remainder1_case1     = [];
	my $real_remainder2_case1     = [];
	#Fill group 1 (for case 1) to min size
	push(@$min_group1_case1,shift(@ordered_samples_real1_tmp))
	  while(scalar(@$min_group1_case1) < $min_size1 &&
		scalar(@ordered_samples_real1_tmp));
	if(scalar(@$min_group1_case1) >= $min_size1)
	  {@$real_remainder1_case1 = @ordered_samples_real1_tmp}
	push(@$min_group1_case1,shift(@nocalls1_tmp))
	  while(scalar(@$min_group1_case1) < $min_size1 &&
		scalar(@nocalls1_tmp));
	#Fill group 2 (for case 1) to min size
	push(@$min_group2_case1,pop(@ordered_samples_real2_tmp))
	  while(scalar(@$min_group2_case1) < $min_size2 &&
		scalar(@ordered_samples_real2_tmp));
	if(scalar(@$min_group2_case1) >= $min_size2)
	  {@$real_remainder2_case1 = @ordered_samples_real2_tmp}
	push(@$min_group2_case1,shift(@nocalls2_tmp))
	  while(scalar(@$min_group2_case1) < $min_size2 &&
		scalar(@nocalls2_tmp));

	#Case 2: right of group 1 versus left of group 2
	@ordered_samples_real1_tmp = @ordered_samples_real1;
	@nocalls1_tmp              = @nocalls1;
	@ordered_samples_real2_tmp = @ordered_samples_real2;
	@nocalls2_tmp              = @nocalls2;
	my $min_group1_case2       = [];
	my $min_group2_case2       = [];
	my $real_remainder1_case2  = [];
	my $real_remainder2_case2  = [];
	#Fill group 1 (for case 2) to min size
	push(@$min_group1_case2,pop(@ordered_samples_real1_tmp))
	  while(scalar(@$min_group1_case2) < $min_size1 &&
		scalar(@ordered_samples_real1_tmp));
	if(scalar(@$min_group1_case1) >= $min_size1)
	  {@$real_remainder1_case2 = @ordered_samples_real1_tmp}
	push(@$min_group1_case2,shift(@nocalls1_tmp))
	  while(scalar(@$min_group1_case2) < $min_size1 &&
		scalar(@nocalls1_tmp));
	#Fill group 2 (for case 2) to min size
	push(@$min_group2_case2,shift(@ordered_samples_real2_tmp))
	  while(scalar(@$min_group2_case2) < $min_size2 &&
		scalar(@ordered_samples_real2_tmp));
	if(scalar(@$min_group2_case2) >= $min_size2)
	  {@$real_remainder2_case2 = @ordered_samples_real2_tmp}
	push(@$min_group2_case2,shift(@nocalls2_tmp))
	  while(scalar(@$min_group2_case2) < $min_size2 &&
		scalar(@nocalls2_tmp));

	##
	## Determine which case is better (from the 2 greedily constructed opts)
	##

	my $case1_score =
	  getGTCallScore([map {$sample_info->{$_}->{GT}} @$min_group1_case1],
			 [map {$sample_info->{$_}->{GT}} @$min_group2_case1]);

	my $case2_score =
	  getGTCallScore([map {$sample_info->{$_}->{GT}} @$min_group1_case2],
			 [map {$sample_info->{$_}->{GT}} @$min_group2_case2]);

	if($case1_score >= $case2_score)
	  {
	    @$min_group1      = @$min_group1_case1;
	    @$min_group2      = @$min_group2_case1;
	    @$real_remainder1 = @$real_remainder1_case1;
	    @$real_remainder2 = @$real_remainder2_case1;
	    $case_leftright   = 1;
	  }
	else
	  {
	    @$min_group1      = @$min_group1_case2;
	    @$min_group2      = @$min_group2_case2;
	    @$real_remainder1 = @$real_remainder1_case2;
	    @$real_remainder2 = @$real_remainder2_case2;
	    $case_leftright   = 0;
	  }

	debug("Min group 1: [@$min_group1] Remainder 1: [@$real_remainder1]\n",
	      "Min group 2: [@$min_group2] Remainder 2: [@$real_remainder2].\n",
	      "Case: ",($case_leftright ? "left/right" : "right/left"),".",
	      {LEVEL => 2});
      }
    else #nogenotype mode
      {
	my($best_state,$best_leftright);
	my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
	my @variant_states  = ('RO',@$ao_keys);
	my $remainder       = [];
	my $best_group1     = [];
	my $best_group2     = [];
	my $best_remainder1 = [];
	my $best_remainder2 = [];
	my $best_gap        = 0;

	debug("Variant (AO/RO) keys: [",join(',',@variant_states),"].",
	      {LEVEL => 3});

	foreach my $state (@variant_states)
	  {
	    my $tmp_group1_1    = [];#Case1: bottom of group 1 vs top of group 2
	    my $tmp_group2_1    = [];
	    my $tmp_group1_2    = [];#Case2: top of group 1 vs bottom of group 2
	    my $tmp_group2_2    = [];
	    my $remainder1_1    = [];
	    my $remainder2_1    = [];
	    my $remainder1_2    = [];
	    my $remainder2_2    = [];

	    my @ordered_observation_ratios1 =
	      sort {compareSampleObservationRatios($a,$b,$state,
						   $expanded_sample_info)}
		grep {$expanded_sample_info->{$_}->{DP}} @$max_group1;
	    my @no_observations1 = grep {!$expanded_sample_info->{$_}->{DP}}
	      @$max_group1;

	    my @ordered_observation_ratios2 =
	      sort {compareSampleObservationRatios($a,$b,$state,
						   $expanded_sample_info)}
		grep {$expanded_sample_info->{$_}->{DP}} @$max_group2;
	    my @no_observations2 = grep {!$expanded_sample_info->{$_}->{DP}}
	      @$max_group2;

	    my @ordered_observation_ratios1_tmp =
	      @ordered_observation_ratios1;
	    my @ordered_observation_ratios2_tmp =
	      @ordered_observation_ratios2;

	    #Try creating group 1 from the left and 2 from the right
	    push(@$tmp_group1_1,shift(@ordered_observation_ratios1_tmp))
	      while(scalar(@$tmp_group1_1) < $min_size1 &&
		    scalar(@ordered_observation_ratios1_tmp));
	    @$remainder1_1 = @ordered_observation_ratios1_tmp;
	    push(@$tmp_group1_1,shift(@no_observations1))
	      while(scalar(@$tmp_group1_1) < $min_size1 &&
		    scalar(@no_observations1));

	    push(@$tmp_group2_1,pop(@ordered_observation_ratios2_tmp))
	      while(scalar(@$tmp_group2_1) < $min_size2 &&
		    scalar(@ordered_observation_ratios2_tmp));
	    @$remainder2_1 = @ordered_observation_ratios2_tmp;
	    push(@$tmp_group2_1,shift(@no_observations2))
	      while(scalar(@$tmp_group2_1) < $min_size2 &&
		    scalar(@no_observations2));

	    my $gap1 =
	      getObsFreqScore([map {$expanded_sample_info->{$_}->{$state} /
				      $expanded_sample_info->{$_}->{DP}}
			       grep {$expanded_sample_info->{$_}->{DP}}
			       @$tmp_group1_1],
			      [map {$expanded_sample_info->{$_}->{$state} /
				      $expanded_sample_info->{$_}->{DP}}
			       grep {$expanded_sample_info->{$_}->{DP}}
			       @$tmp_group2_1]);
	    my $leftright = 1;


	    #Now try creating group 1 from the right and 2 from the left (if
	    #necessary)
	    if($min_size1 != scalar(@$max_group1) ||
	       $min_size2 != scalar(@$max_group2))
	      {
		#Try creating group 1 from the right and 2 from the left
		@ordered_observation_ratios1_tmp =
		  @ordered_observation_ratios1;
		@no_observations1 = grep {!$expanded_sample_info->{$_}->{DP}}
		  @$max_group1;

		@ordered_observation_ratios2_tmp =
		  @ordered_observation_ratios2;
		@no_observations2 = grep {!$expanded_sample_info->{$_}->{DP}}
		  @$max_group2;

		push(@$tmp_group1_2,pop(@ordered_observation_ratios1_tmp))
		  while(scalar(@$tmp_group1_2) < $min_size1 &&
		        scalar(@ordered_observation_ratios1_tmp));
		@$remainder1_2 = @ordered_observation_ratios1_tmp;
		push(@$tmp_group1_2,shift(@no_observations1))
		  while(scalar(@$tmp_group1_2) < $min_size1 &&
			scalar(@no_observations1));

		push(@$tmp_group2_2,shift(@ordered_observation_ratios2_tmp))
		  while(scalar(@$tmp_group2_2) < $min_size2 &&
		        scalar(@ordered_observation_ratios2_tmp));
		@$remainder2_2 = @ordered_observation_ratios2_tmp;
		push(@$tmp_group2_2,shift(@no_observations2))
		  while(scalar(@$tmp_group2_2) < $min_size2 &&
			scalar(@no_observations2));

		my $gap2 =
		  getObsFreqScore([map {$expanded_sample_info->{$_}->{$state} /
					  $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$tmp_group1_2],
				  [map {$expanded_sample_info->{$_}->{$state} /
					  $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$tmp_group2_2]);

		#The version of the groups with the larger gap is better
		if($gap2 > $gap1)
		  {
		    $gap1           = $gap2;
		    @$tmp_group1_1  = @$tmp_group1_2;
		    @$tmp_group2_1  = @$tmp_group2_2;
		    @$remainder1_1  = @$remainder1_2;
		    @$remainder2_1  = @$remainder2_2;
		    $leftright = 0;
		  }
	      }

	    #Now that we have the best group for this state, let's compare
	    #with previous states
	    if($gap1 > $best_gap || !defined($best_state))
	      {
		$best_gap         = $gap1;
		$best_state       = $state;
		@$best_group1     = @$tmp_group1_1;
		@$best_group2     = @$tmp_group2_1;
		@$best_remainder1 = @$remainder1_1;
		@$best_remainder2 = @$remainder2_1;
		$best_leftright   = $leftright;
	      }
	  }

	@$min_group1      = @$best_group1;
	@$min_group2      = @$best_group2;
	@$real_remainder1 = @$best_remainder1;
	@$real_remainder2 = @$best_remainder2;
	$case_leftright   = $best_leftright;
      }

    if(scalar(@$min_group1) < $min_size1 || scalar(@$min_group1) == 0)
      {error("Min sample group 1 size: [",scalar(@$min_group1),
	     "] less than minimum: [",(defined($min_size1) ?
				       $min_size1 : 'undef'),"].")}
    if(scalar(@$min_group2) < $min_size2 || scalar(@$min_group2) == 0)
      {error("Min sample group 2 size: [",scalar(@$min_group2),
	     "] less than minimum: [",(defined($min_size2) ?
				       $min_size2 : 'undef'),"].")}

    return($min_group1,$min_group2,
	   $real_remainder1,$real_remainder2,
	   $case_leftright);
  }


#This sorts via observation ratios.  Assumes 0 depth is 0 observations, so
#filter supplied samples for a depth greater than 0.
sub compareSampleObservationRatios
  {
    my $left_sample   = $_[0];
    my $right_sample  = $_[1];
    my $variant_state = $_[2];
    my $sample_info   = $_[3];

    return(($sample_info->{$left_sample}->{$variant_state} /
	    ($sample_info->{$left_sample}->{DP} ?
	     $sample_info->{$left_sample}->{DP} : 1)) <=>
	   ($sample_info->{$right_sample}->{$variant_state} /
	    ($sample_info->{$right_sample}->{DP} ?
	     $sample_info->{$right_sample}->{DP} : 1)));
  }


#Returns a number that has been rounded to a number of significant digits.  Only
#rounds decimal values between 0 and 1 and no scientific notation.  Otherwise,
#it returns the number as-is.
sub sigdec
  {
    my $dec = $_[0];
    my $digs = defined($_[1]) ? $_[1] : 4;

    if($dec !~ /^0*\.\d+$/)
      {return($dec)}

    if($digs == 0)
      {return($dec < 0.5 ? 0 : 1)}
    elsif($digs < 0)
      {
	error("Invalid number of significant digits: [$digs].");
	return($dec);
      }

    $digs--;

    if($dec =~ /(0*\.(0*[1-9]\d{$digs}))(\d)/)
      {
	my $trunc = $1;
	my $dp    = length($2);
	my $next  = $3;
	if($next >= 5)
	  {
	    my $inc = '0.' . ('0' x ($dp - 1)) . '1';
	    return($trunc + $inc);
	  }
	else
	  {return($trunc)}
      }

    return($dec);
  }

#This allows us to equate decimal values when sorting.  Just supply 2 decimal
#values.  If the allotment of digits is the same, 0 is returned, otherwise the
#result of <=>
sub compareDec
  {
    my $left  = $_[0];
    my $right = $_[1];

    if($left eq $right)
      {return(0)}

    return($left <=> $right);
  }

sub intRound
  {
    my $num = $_[0];
    if($num =~ /^\d*\.(\d)\d*$/)
      {
	my $d = $1;
	$num = int($num) + ($d < 5 ? 0 : 1);
      }
    return($num);
  }

#Globals used: $min_depth, $max_depth
sub sampleGroupPairPasses
  {
    my $group1           = $_[0];
    my $group2           = $_[1];
    my $sample_info      = $_[2];
    my $ave_depth_filter = $_[3];

    my $pass = 0;

    my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
    my $dp_score =
      getDepthScore([map {$expanded_sample_info->{$_}->{DP}} @$group1],
		    [map {$expanded_sample_info->{$_}->{DP}} @$group2]);
    if($ave_depth_filter && $dp_score < ($min_depth / $max_depth))
      {return($pass)}

    if($genotype)
      {
	my $gt_score =
	  getGTCallScore([map {$sample_info->{$_}->{GT}} @$group1],
			 [map {$sample_info->{$_}->{GT}} @$group2]);
	$pass = ($gt_score >= $min_gt_score);
      }
    else
      {
	my @variant_states = ('RO',@$ao_keys);
	foreach my $state (@variant_states)
	  {
	    foreach(@$group1,@$group2)
	      {debug("Observations for sample [$_] and state [$state]: ",
		     "$expanded_sample_info->{$_}->{$state}")}
	    my $score =
	      getObsFreqScore([map {$expanded_sample_info->{$_}->{$state} /
				      $expanded_sample_info->{$_}->{DP}}
			       grep {$expanded_sample_info->{$_}->{DP}}
			       @$group1],
			      [map {$expanded_sample_info->{$_}->{$state} /
				      $expanded_sample_info->{$_}->{DP}}
			       grep {$expanded_sample_info->{$_}->{DP}}
			       @$group2]);
	    my $any_real1 =
	      scalar(grep {$sample_info->{$_}->{GT} !~ /\./} @$group1);
	    my $any_real2 =
	      scalar(grep {$sample_info->{$_}->{GT} !~ /\./} @$group2);

	    if($any_real1 && $any_real2 &&
	       $score >= $separation_gap)
	      {
		$pass = 1;
		last;
	      }
	  }
      }

    debug("Group 1: [@$group1] GT values: [",
	  join(',',map {$sample_info->{$_}->{GT}} @$group1),"]\n",
	  "Group 2: [@$group2] GT values: [",
	  join(',',map {$sample_info->{$_}->{GT}} @$group2),"]\n",
	  "Pass: $pass");

    return($pass);
  }


sub getBestScoringData
  {
    my $group1      = $_[0];
    my $group2      = $_[1];
    my $sample_info = $_[2];

    my $gt_score   = 0;  #Lowest possible is 0 when groups are supplied
    my $or_score   = -2; #Lowest possible is -1 when groups are supplied
    my $gt_state   = '';
    my $or_state   = '';
    my $gt_data1   = [];
    my $gt_data2   = [];
    my $or_data1   = [];
    my $or_data2   = [];

    my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);

    my $dpscore =
      getDepthScore([map {$expanded_sample_info->{$_}->{DP}} @$group1],
		    [map {$expanded_sample_info->{$_}->{DP}} @$group2]);

    ##
    ## Calculate genotype score
    ##

    #The data is the raw genotype calls
    @$gt_data1 = map {$sample_info->{$_}->{GT}} @$group1;
    @$gt_data2 = map {$sample_info->{$_}->{GT}} @$group2;

    $gt_score = getGTCallScore($gt_data1,$gt_data2);

    my $g1_gts = {map {$sample_info->{$_}->{GT} => 1}
		  grep {$sample_info->{$_}->{GT} !~ /\./} @$group1};
    my $g2_gts = {map {$sample_info->{$_}->{GT} => 1}
		  grep {$sample_info->{$_}->{GT} !~ /\./} @$group2};

    #The state is the combo of unique genotypes present in each group
    $gt_state  = (join('+',sort(keys(%$g1_gts))) . ';' .
		  join('+',sort(keys(%$g2_gts))));

    ##
    ## Calculate best observation ratio score
    ##

    my @variant_states = ('RO',@$ao_keys);
    my $cur_score = -2; #Lowest possible is -1 when groups are supplied
    foreach my $cur_state (@variant_states)
      {
	$cur_score =
	  getObsFreqScore([map {$expanded_sample_info->{$_}->{$cur_state} /
				  $expanded_sample_info->{$_}->{DP}}
			   grep {$expanded_sample_info->{$_}->{DP}}
			   @$group1],
			  [map {$expanded_sample_info->{$_}->{$cur_state} /
				  $expanded_sample_info->{$_}->{DP}}
			   grep {$expanded_sample_info->{$_}->{DP}}
			   @$group2]);

	#Base the best score on the variant state with the best separation
	#gap.  If there are multiple variant states that produce the same
	#best score, go with the one that's not the same as the reference.
	if($cur_score > $or_score ||
	   (#The decimal values are the same and the cur state is not 'RO'
	    ($cur_score == $or_score || $cur_score eq $or_score) &&
	    $cur_state ne 'RO'))
	  {
	    $or_score = $cur_score;
	    my $tmp_state = $cur_state;
	    $tmp_state =~ s/AO(\d)/$1/;
	    $tmp_state = 0 if($tmp_state eq 'RO');
	    $tmp_state = 1 if($tmp_state eq 'AO');
	    $or_state = $tmp_state;
	    #The data is the list of observation ratios
	    @$or_data1 = (map {$expanded_sample_info->{$_}->{DP} ?
				 "$expanded_sample_info->{$_}->{$cur_state}" .
				   "/$expanded_sample_info->{$_}->{DP}" : '.'}
			  @$group1);
	    @$or_data2 = (map {$expanded_sample_info->{$_}->{DP} ?
				 "$expanded_sample_info->{$_}->{$cur_state}" .
				   "/$expanded_sample_info->{$_}->{DP}" : '.'}
			  @$group2);
	  }
      }

    if($dpscore <= 0)
      {return({DP_SCORE   => 0,

	       GT_SCORE   => ($dynamic_group_creation ? 0 : -1),
	       GT_STATE   => '.',
	       GROUP1_GTS => $gt_data1,
	       GROUP2_GTS => $gt_data2,

	       OR_SCORE   => 0,
	       OR_STATE   => '.',
	       GROUP1_ORS => $or_data1,
	       GROUP2_ORS => $or_data2})}

    return({DP_SCORE   => $dpscore,

	    GT_SCORE   => $gt_score,
	    GT_STATE   => $gt_state,
	    GROUP1_GTS => $gt_data1,
	    GROUP2_GTS => $gt_data2,

	    OR_SCORE   => $or_score,
	    OR_STATE   => $or_state,
	    GROUP1_ORS => $or_data1,
	    GROUP2_ORS => $or_data2});
  }

#Calculated Ratio of Resolution - It takes 2 groups of genotype calls where the
#calls can be any of a set of numbers or a dot (indicating no data).  Each
#number occurrence is for a sample.  A perfect score of 1 is achieved when there
#are no common calls between the 2 groups.  A bottom score of 0 is when all
#calls are common and evenly populated between the 2 groups.
sub getGTCallScore
  {
    my $group1              = $_[0];
    my $group2              = $_[1];

    my $ratio_of_resolution = 0;

    my $group1_call_counts  = {};
    my $group2_call_counts  = {};
    my $call_hash           = {};
    my $ambig1_counts       = 0;
    my $ambig2_counts       = 0;

    #Count the specific calls in each group, the total, and track unique calls
    foreach my $call (@$group1)
      {
	if($call eq '.')
	  {$ambig1_counts++}
	else
	  {
	    $call_hash->{$call} = 1;
	    $group1_call_counts->{$call}++;
	  }
      }
    foreach my $call (@$group2)
      {
	if($call eq '.')
	  {$ambig2_counts++}
	else
	  {
	    $call_hash->{$call} = 1;
	    $group2_call_counts->{$call}++;
	  }
      }

    #Count the total number of unique calls.  This will be the number of ways a
    #sample can be identified based on its genotype call.  We will use it to see
    #how well genotype calls divide up the samples in the given groups.
    my $num_states = scalar(keys(%$call_hash));

    #If there are different calls and each group is populated
    if($num_states > 1 &&
       scalar(keys(%$group1_call_counts)) && scalar(keys(%$group2_call_counts)))
      {
	#The ambiguous fraction is the number of samples in the "ambiguous
	#category" divided by the number of known states.  This assumes that the
	#unknown sample states has an equal chance of being one of the other
	#known/seen states
	my $ambig1_fraction     = $ambig1_counts / $num_states;
	my $ambig2_fraction     = $ambig2_counts / $num_states;
	my $group1_weighted_sum = 0;
	my $group1_sum          = 0;

	#For each possible known genotype call among the 2 groups
	foreach my $call (keys(%$call_hash))
	  {
	    #If a group doesn't have that call (which is good),
	    #initialize its count
	    if(!exists($group1_call_counts->{$call}))
	      {$group1_call_counts->{$call} = 0}
	    if(!exists($group2_call_counts->{$call}))
	      {$group2_call_counts->{$call} = 0}

	    #We're going to base the call on being able to tease out group 1
	    #from group 2 (we could do it either way, but we shouyld get the
	    #same result).  We want to add the number of samples from group 1
	    #with this call multiplied by the ratio of the number of samples
	    #with this call over the total number of samples with this call in
	    #both groups (this is the ratio of resolution).  We also spread out
	    #a fraction of the samples with ambiguous calls among each call.
	    $group1_weighted_sum +=
	      ($group1_call_counts->{$call} + $ambig1_fraction)**2 /
		($group1_call_counts->{$call} + $ambig1_fraction +
		 $group2_call_counts->{$call} + $ambig2_fraction);
	    #We will also keep track of the number of samples in group 1 with
	    #this call.
	    $group1_sum += $group1_call_counts->{$call} + $ambig1_fraction;
	  }

	#Should be greater than 0 - just being safe
	if($group1_sum > 0)
	  {
	    $ratio_of_resolution = $group1_weighted_sum / $group1_sum;

	    #All scores will be between 0.5 and 1, so normalize to between 0 and
	    #1
	    $ratio_of_resolution -= 0.5;
	    $ratio_of_resolution *= 2.0;

	    if($ratio_of_resolution < 0 || $ratio_of_resolution > 1.0)
	      {error("Invalid ratio of resolution score.")}
	  }
      }

    return($ratio_of_resolution);
  }


#Globals_used: $min_depth, $max_depth
sub getDepthScore
  {
    my $group1 = $_[0];
    my $group2 = $_[1];

    if(scalar(@$group1) == 0 || scalar(@$group2) == 0)
      {
	error("One or both sample groups of depth values is empty.");
	return(0);
      }

    my $sum1 = 0;
    foreach my $dp (@$group1)
      {$sum1 += ($dp > $max_depth ? $max_depth : $dp)}
    my $score1 = $sum1 / ($max_depth * scalar(@$group1));

    my $sum2 = 0;
    foreach my $dp (@$group2)
      {$sum2 += ($dp > $max_depth ? $max_depth : $dp)}
    my $score2 = $sum2 / ($max_depth * scalar(@$group2));

    return($score1 < $score2 ? $score1 : $score2);
  }

#Call this to create sample groups dynamically (when no sample groups have been
#defined).  It starts by creating the best groups it can using the minimum group
#sizes.  When in genotype mode, that means the groups gave no common genotype
#(or as few common genotypes as possible.  When in nogenotype mode, it selects
#the variant state that results in the largest observation ratio gap when
#drawing from opposite ends of a sample list ordered by observation ratios of
#the selected variant state.  In each case, the best minimum groups are grown
#until just before they cross the threshold making the groups a non-hit, meaning
#in genotype mode, it grows the sample groups up until they would end up with a
#common genotype, or in nogenotype mode, it grows them until just before the
#comparison of the observation ratios of the groups dips below the separation
#gap threshold.
#Known issue: When selecting between 2 minimum group sizes that have the same
#"score" (i.e. the same gap size or assortment of unique genotypes), the
#selection is made arbitrarily.  It doesn't look ahead to see which selection
#would result in the largest group sizes at the grow step.
sub createDynamicMaxSampleGroupPair
  {
    my $sample_info     = $_[0];
    my $min_group_sizes = $_[1];

    my $groups = []; #A 2D array

    if(scalar(@$min_group_sizes) % 2)
      {
	error("Odd number of minimum grouyp sizes encountered: [",
	      scalar(@$min_group_sizes),"].  Must be even.  Unable to ",
	      "proceed.");
	quit(15);
      }
    elsif(scalar(@$min_group_sizes) == 0)
      {
	error("Empty minimum group sizes array.  Unable to proceed.");
	quit(16);
      }

    if(scalar(keys(%$sample_info)) == 0)
      {
	error("Empty sample info hash.  Unable to proceed.");
	quit(17);
      }

    for(my $mi = 0;$mi < scalar(@$min_group_sizes);$mi += 2)
      {
	#Make sure the first size is the larger size
	my($min_size1,$min_size2) = sort {$b <=> $a}
	  ($min_group_sizes->[$mi],$min_group_sizes->[$mi + 1]);
	my $group1 = [];
	my $group2 = [];

	if(($min_size1 + $min_size2) > scalar(keys(%$sample_info)))
	  {
	    error("Invalid minimum sample group sizes.  Pair [",($mi + 1),
		  "] of minimum group sizes [$min_size1,$min_size2] must not ",
		  "sum [",($min_size1 + $min_size2),"] to more than the ",
		  "number of samples: [",scalar(keys(%$sample_info)),
		  "].  Unable to proceed.");
	    quit(18);
	  }

	##
	## The following code differs from that in
	## createStaticMinSampleGroupPair because this version creates the pair
	## of groups using a single sample list and an empty list of sample
	## groups whereas the code in createStaticMinSampleGroupPair uses 2
	## populated full sample groups and creates a minimum group out of each
	##

	#If we're in genotype mode
	if($genotype)
	  {
	    #Establish the ordering of the samples by genotype abundance
	    my $genotype_counts = {};
	    foreach my $sample (keys(%$sample_info))
	      {$genotype_counts->{$sample_info->{$sample}->{GT}}++}
	    my @ordered_gts_real =
	      sort {$genotype_counts->{$sample_info->{$b}->{GT}} <=>
		      $genotype_counts->{$sample_info->{$a}->{GT}}}
		grep {$sample_info->{$_}->{GT} !~ /\./} keys(%$sample_info);
	    my @nocalls = (grep {$sample_info->{$_}->{GT} =~ /\./}
			   keys(%$sample_info));
	    my @samples_remaining = (grep {defined($_)}
				     @ordered_gts_real,@nocalls);
	    my $call = '';
	    while(scalar(@samples_remaining) &&
		  scalar(@$group1) < $min_size1 &&
		  scalar(@$group2) < $min_size2)
	      {
		#Start by populating the larger sample group using the more
		#abundant genotype call
		if(scalar(@$group1) < $min_size1)
		  {
		    if(scalar(@ordered_gts_real))
		      {$call = $sample_info->{shift(@ordered_gts_real)}->{GT}}
		    elsif(scalar(@nocalls))
		      {$call = $sample_info->{shift(@nocalls)}->{GT}}
		    else
		      {
			$call = $sample_info->{$samples_remaining[0]}->{GT};
			warning("Ran out of calls in dynamic sample group ",
				"creation.");
			last;
		      }

		    #Add a new call to group 1 (the larger group)
		    if($call eq '')
		      {
			push(@$group1,shift(@samples_remaining))
			  while(scalar(@$group1) < $min_size1 &&
				scalar(@samples_remaining));
		      }
		    else
		      {
			push(@$group1,
			     grep {$sample_info->{$_}->{GT} eq $call}
			     @samples_remaining);
		      }

		    #Trim back the group if it ended up too large
		    if(scalar(@$group1) > $min_size1)
		      {pop(@$group1) while(scalar(@$group1) > $min_size1)}

		    #Remove samples from those remaining
		    @samples_remaining =
		      grep {my $s=$_;scalar(grep {$_ eq $s} @$group1) == 0}
			@samples_remaining;
		  }

		#Now try to populate the smaller sample group using the less
		#abundant genotype call (if one exists)
		if(scalar(@$group2) < $min_size2)
		  {
		    if(scalar(@ordered_gts_real))
		      {$call = $sample_info->{pop(@ordered_gts_real)}->{GT}}
		    elsif(scalar(@nocalls))
		      {$call = $sample_info->{shift(@nocalls)}->{GT}}
		    else
		      {
			my @tmp = grep {$sample_info->{$_}->{GT} !~ /\./}
			  @samples_remaining;
			if(scalar(@tmp))
			  {$call = $sample_info->{$tmp[-1]}->{GT}}
			else
			  {$call = ''}
			warning("Ran out of calls in dynamic sample group ",
				"creation.");
			last;
		      }

		    #Add a new call to group 2 (the smaller group)
		    if($call eq '')
		      {
			push(@$group2,shift(@samples_remaining))
			  while(scalar(@$group2) < $min_size2 &&
				scalar(@samples_remaining));
		      }
		    else
		      {
			push(@$group2,
			     grep {$sample_info->{$_}->{GT} eq $call}
			     @samples_remaining);
		      }

		    #Trim back the group if it ended up too large
		    if(scalar(@$group2) > $min_size2)
		      {pop(@$group2) while(scalar(@$group2) > $min_size2)}

		    #Remove samples from those remaining
		    @samples_remaining =
		      grep {my $s=$_;scalar(grep {$_ eq $s} @$group2) == 0}
			@samples_remaining;
		  }
	      }

	    #Grow the groups to the max size as much as possible without adding
	    #to inconsistencies
	    my $g1_gts = {map {$sample_info->{$_}->{GT} => 1}
			  grep {$sample_info->{$_}->{GT} !~ /\./} @$group1};
	    my $g2_gts = {map {$sample_info->{$_}->{GT} => 1}
			  grep {$sample_info->{$_}->{GT} !~ /\./} @$group2};
	    foreach my $sample (@samples_remaining)
	      {
		my $gt = $sample_info->{$sample}->{GT};
		if(exists($g1_gts->{$gt}) && !exists($g2_gts->{$gt}))
		  {push(@$group1,$sample)}
		elsif(!exists($g1_gts->{$gt}) && exists($g2_gts->{$gt}))
		  {push(@$group2,$sample)}
	      }

	    #Make the groups match the original order of the minimum sizes
	    push(@$groups,($min_group_sizes->[$mi] == $min_size1 ?
			   ($group1,$group2) : ($group2,$group1)));
	  }
	else #nogenotype - use observation ratios - easier than above
	  {
	    my($expanded_sample_info,$ao_keys) = expandSampleInfo($sample_info);
	    my @variant_states = ('RO',@$ao_keys);
	    my $remainder    = [];
	    my $best_group1  = [];
	    my $best_group2  = [];
	    my($best_state);
	    my $best_gap     = 0;
	    foreach my $state (@variant_states)
	      {
		my $tmp_group1_1 = [];
		my $tmp_group2_1 = [];
		my $tmp_group1_2 = [];
		my $tmp_group2_2 = [];

		my @ordered_observation_ratios =
		  sort {compareSampleObservationRatios($a,$b,$state,
						       $expanded_sample_info)}
		    grep {$expanded_sample_info->{$_}->{DP}}
		      keys(%$sample_info);
		my @no_observations = grep {!$expanded_sample_info->{$_}->{DP}}
		  keys(%$sample_info);

		#Try creating group 1 from the left and 2 from the right
		my @ordered_observation_ratios_tmp =
		  @ordered_observation_ratios;
		while((scalar(@$tmp_group1_1) < $min_size1 ||
		       scalar(@$tmp_group2_1) < $min_size2) &&
		      scalar(@ordered_observation_ratios_tmp))
		  {
		    push(@$tmp_group1_1,shift(@ordered_observation_ratios_tmp))
		      if(scalar(@$tmp_group1_1) < $min_size1);
		    push(@$tmp_group2_1,pop(@ordered_observation_ratios_tmp))
		      if(scalar(@$tmp_group2_1) < $min_size2 &&
			 scalar(@ordered_observation_ratios_tmp));
		  }
		while((scalar(@$tmp_group1_1) < $min_size1 ||
		       scalar(@$tmp_group2_1) < $min_size2) &&
		      scalar(@no_observations))
		  {
		    push(@$tmp_group1_1,shift(@no_observations))
		      if(scalar(@$tmp_group1_1) < $min_size1);
		    push(@$tmp_group2_1,shift(@no_observations))
		      if(scalar(@$tmp_group2_1) < $min_size2 &&
			 scalar(@no_observations));
		  }
		my $remainder_tmp    = [@ordered_observation_ratios_tmp];
		my $no_obs_remainder = [@no_observations];

		my $gap1 =
		  getObsFreqScore([map {$expanded_sample_info->{$_}->{$state} /
					  $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$tmp_group1_1],
				  [map {$expanded_sample_info->{$_}->{$state} /
					  $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$tmp_group2_1]);

		#Now try the opposite (if the sizes are different)
		if($min_size1 != $min_size2)
		  {
		    #Try creating group 1 from the right and 2 from the left
		    @ordered_observation_ratios_tmp =
		      @ordered_observation_ratios;
		    @no_observations = grep {!$expanded_sample_info->{$_}->{DP}}
		      keys(%$sample_info);
		    while((scalar(@$tmp_group1_2) < $min_size1 ||
			   scalar(@$tmp_group2_2) < $min_size2) &&
			  scalar(@ordered_observation_ratios_tmp))
		      {
			push(@$tmp_group1_2,
			     pop(@ordered_observation_ratios_tmp))
			  if(scalar(@$tmp_group1_2) < $min_size1);
			push(@$tmp_group2_2,
			     shift(@ordered_observation_ratios_tmp))
			  if(scalar(@$tmp_group2_2) < $min_size2 &&
			     scalar(@ordered_observation_ratios_tmp));
		      }
		    while((scalar(@$tmp_group1_2) < $min_size1 ||
			   scalar(@$tmp_group2_2) < $min_size2) &&
			  scalar(@no_observations))
		      {
			push(@$tmp_group1_2,shift(@no_observations))
			  if(scalar(@$tmp_group1_2) < $min_size1);
			push(@$tmp_group2_2,shift(@no_observations))
			  if(scalar(@$tmp_group2_2) < $min_size2 &&
			     scalar(@no_observations));
		      }

		    my $gap2 =
		      getObsFreqScore([map
				       {$expanded_sample_info->{$_}->{$state} /
					  $expanded_sample_info->{$_}->{DP}}
				       grep {$expanded_sample_info->{$_}->{DP}}
				       @$tmp_group1_1],
				      [map
				       {$expanded_sample_info->{$_}->{$state} /
					  $expanded_sample_info->{$_}->{DP}}
				       grep {$expanded_sample_info->{$_}->{DP}}
				       @$tmp_group2_1]);

		    #The version of the groups with the larger gap is better
		    if($gap2 > $gap1)
		      {
			$gap1 = $gap2;
			@$tmp_group1_1 = @$tmp_group1_2;
			@$tmp_group2_1 = @$tmp_group2_2;
			@$remainder_tmp =
			  reverse(@ordered_observation_ratios_tmp);
			@$no_obs_remainder = @no_observations;
		      }
		  }

		#Now that we have the best group for this state, let's compare
		#with previous states
		if($gap1 > $best_gap || !defined($best_state))
		  {
		    $best_gap     = $gap1;
		    $best_state   = $state;
		    @$best_group1 = @$tmp_group1_1;
		    @$best_group2 = @$tmp_group2_1;
		    @$remainder   = @$remainder_tmp;
		  }
	      }

	    #Grow the groups to max size without exceeding the separation gap
	    #We're going to ignore samples with no observations in the grow step
	    while(scalar(@$remainder))
	      {
		my $first_sample = $remainder->[0];
		my $last_sample  = $remainder->[-1];

		#Determine the existing averages
		my $cur_score =
		  getObsFreqScore([map
				   {$expanded_sample_info->{$_}->{$best_state} /
				      $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$best_group1],
				  [map
				   {$expanded_sample_info->{$_}->{$best_state} /
				      $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$best_group2]);

		#If the minimum group size is already less than the separation
		#gap threshold, do not grow.
		last if($cur_score < $separation_gap);

		#Whether or not @$remainder has more than 1 member, the result
		#will be the same
		my $first_to_g1_score =
		  getObsFreqScore([map
				   {$expanded_sample_info->{$_}->{$best_state} /
				      $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   (@$best_group1,$first_sample)],
				  [map
				   {$expanded_sample_info->{$_}->{$best_state} /
				      $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$best_group2]);
		my $last_to_g2_score =
		  getObsFreqScore([map
				   {$expanded_sample_info->{$_}->{$best_state} /
				      $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   @$best_group1],
				  [map
				   {$expanded_sample_info->{$_}->{$best_state} /
				      $expanded_sample_info->{$_}->{DP}}
				   grep {$expanded_sample_info->{$_}->{DP}}
				   (@$best_group2,$last_sample)]);

		#Determine which will result in a smaller gap change
		my $better = 1;
		if($last_to_g2_score > $first_to_g1_score)
		  {$better = 2}

		#If the better gap change also results in a gap that's larger
		#than the separation gap threshold, add it to the best group
		if($better == 1 &&
		   $first_to_g1_score >= $separation_gap)
		  {
		    push(@$best_group1,$first_sample);
		    shift(@$remainder);
		  }
		elsif($better == 2 &&
		      $last_to_g2_score >= $separation_gap)
		  {
		    push(@$best_group2,$last_sample);
		    pop(@$remainder);
		  }
		else
		  {last}
	      }

	    push(@$groups,($best_group1,$best_group2));
	  }
      }

    debug("Returning groups of sizes: [",join(',',map {scalar(@$_)} @$groups),
	  "].",{LEVEL => 2});

    return(wantarray ? @$groups : $groups);
  }

sub mean
  {
    if(scalar(@_) != 1)
      {
	error("Invalid input.  Exactly 1 array of non-zero size is required.",
	      {DETAIL => '  ' . scalar(@_) . ' argument provided.'});
	return(0);
      }
    elsif(ref($_[0]) ne 'ARRAY')
      {
	error("Invalid input.  Array reference required.",
	      {DETAIL => '  ' . (ref($_[0]) eq '' ? 'SCALAR (non-reference)' :
				 ref($_[0]) . ' reference') . ' provided.'});
	return(0);
      }

    my $array = $_[0];
    return(0) unless(scalar(@$array));
    my $sum = 0;
    foreach my $val (@$array)
      {$sum += $val}
    return($sum / scalar(@$array));
  }

#Globals used: $gap_measure
sub getObsFreqScore
  {
    my $group1_freqs = $_[0];
    my $group2_freqs = $_[1];

    my $score = -1;
    if(scalar(@_) < 2)
      {
	error("2 sample groups required.");
	return($score);
      }

    if(scalar(@$group1_freqs) == 0 || scalar(@$group2_freqs) == 0)
      {return($score)}

    if($gap_measure eq 'mean')
      {$score = getMeanDiffScore($group1_freqs,$group2_freqs)}
    elsif($gap_measure eq 'edge')
      {$score = getEdgeDiffScore($group1_freqs,$group2_freqs)}
    else
      {
	$score = 0;
	error("Invalid --gap-measure: [$gap_measure].");
      }

    return($score);
  }

sub getMeanDiffScore
  {
    my $ave1 = mean($_[0]);
    my $ave2 = mean($_[1]);

    return(abs($ave1 - $ave2));
  }

#This returns a score between -1 and 1 where -1 to 0 indicates degree of overlap
#and 0 to 1 is degree of separation
#Globals used: $dynamic_group_creation
sub getEdgeDiffScore
  {
    my $group1_freqs = $_[0];
    my $group2_freqs = $_[1];
    my $score        = -1;

    if(scalar(@_) < 2 ||
       scalar(@$group1_freqs) == 0 || scalar(@$group2_freqs) == 0)
      {
	error("Invalid input.  2 arrays of non-zero size are required.",
	      {DETAIL => '  ' . (scalar(@_) < 2 ? scalar(@_) . " provided." :
				 (scalar(@$group1_freqs) == 0 ?
				  'First' : 'Second') . " array too small.")});
	return($score);
      }

    my $min_first  = (sort {compareDec($a,$b)} @$group1_freqs)[0];
    my $max_first  = (sort {compareDec($b,$a)} @$group1_freqs)[0];
    my $min_second = (sort {compareDec($a,$b)} @$group2_freqs)[0];
    my $max_second = (sort {compareDec($b,$a)} @$group2_freqs)[0];

    #If either group contains the other
    if(($min_first <= $min_second && $max_first >= $max_second) ||
       ($min_second <= $min_first && $max_second >= $max_first))
      {$score = ($dynamic_group_creation ? 0 : -1)}
    elsif($min_first < $min_second) #First group is lesser
      {$score = $min_second - $max_first}
    else #first group is greater
      {$score = $min_first - $max_second}

    if($score < -1 || $score > 1)
      {
	error("Score outside of expected range: [$score].",
	      {DETAIL => 'The score should be between -1 and 1.  This is a ' .
	       'bug.  Please report it here: https://github.com/hepcat72/' .
	       'vcfSampleCompare/issues.'});
      }

    debug("Edge Diff Score: $score");

    return($score);
  }

sub expandSampleInfo
  {
    my $sample_info          = $_[0];
    my $expanded_sample_info = {};
    my $ao_keys              = {};

    foreach my $sample (keys(%$sample_info))
      {
	my @real_alts = split(/,/,$sample_info->{$sample}->{ALT},-1);

	foreach my $key (keys(%{$sample_info->{$sample}}))
	  {
	    my $val  = ($sample_info->{$sample}->{$key} eq '.' && $key ne 'GT' ?
			0 : $sample_info->{$sample}->{$key});
	    my @alts = split(/,/,$val,-1);

	    if(scalar(@alts) != 1 && ($key eq 'RO' || $key eq 'DP'))
	      {error("Multiple values found in $key key [$val].",
		     {DETAIL => ('This script assumes that the FORMAT ' .
				 'keys "DP" and "RO" each have a single ' .
				 '(comma-delimited) value, but found more ' .
				 'than 1.')})}
	    elsif($key eq 'AO' && scalar(@real_alts) != 1 &&
		  scalar(@alts) == 1 && $val ne '.' && $val ne '0')
	      {
		error("Single value found in $key key [$val] but multiple ALT ",
		      "values: [$sample_info->{$sample}->{ALT}].  Cannot ",
		      "associate it with an ALT state.  Setting zeroes.",
		      {DETAIL => ('Multiple ALT values must map to the same ' .
				  'number of observation values for key ' .
				  "$key.")});
		@alts = map {0} @real_alts;
	      }
	    elsif($key eq 'AO' && scalar(@real_alts) != 1 &&
		  scalar(@alts) == 1 && ($val eq '.' || $val eq '0'))
	      {@alts = map {0} @real_alts}

	    if(scalar(@alts) == 1)
	      {
		$expanded_sample_info->{$sample}->{$key} = $val;
		if($key eq 'AO')
		  {$ao_keys->{AO}++}
	      }
	    else
	      {
		if($key eq 'AO')
		  {foreach my $key (map {"AO$_"} (1..scalar(@alts)))
		     {$ao_keys->{$key}++}}

		for(my $i = 0;$i <= $#alts;$i++)
		  {$expanded_sample_info->{$sample}->{$key .($i+1)} =
		     ($alts[$i] eq '.' && $key ne 'GT' ? 0 : $alts[$i])}
	      }
	  }
      }

    return($expanded_sample_info,[sort(keys(%$ao_keys))]);
  }

sub max
  {
    my @vals = @_;
    return(undef) unless(scalar(@vals));
    my $max  = $vals[0];
    foreach my $val (@vals)
      {if(!defined($max) || $val > $max)
	 {$max = $val}}
    return($max);
  }

sub validateSampleGroupNames
  {
    my $sample_names  = $_[0];
    my $sample_groups = $_[1];

    my $status = 1; #1 = success/validated
    my $unique = {};
    foreach my $sample (@$sample_names)
      {$unique->{$sample}++}
    foreach my $dupe (grep {$unique->{$_} > 1} keys(%$unique))
      {
	$status = 0;
	error("Sample name [$dupe] occurs [$unique->{$dupe}] in the vcf ",
	      "file.",
	      {DETAIL => 'Sample names must be unique when -s is supplied'});
      }

    my $missing = {};
    foreach my $pair_index ((0..$#{$sample_groups}))
      {
	foreach my $sample_name (grep {!exists($unique->{$_})}
				 @{$sample_groups->[$pair_index]})
	  {
	    $status = 0;
	    error("Sample name submitted with -s [$sample_name] was not ",
		  "found in the vcf file.",
		  {DETAIL => join('',('Sample names submitted with -s must ',
				      'exactly match those present on the ',
				      'header line in the vcf file (the line ',
				      'starting with "#CHROM").  The VCF ',
				      'file contains: [',
				      join(',',@$sample_names),'].'))});
	  }
      }

    return($status);
  }

sub isUnsignedInteger
  {
    my $val = $_[0];

    if(defined($val) && ref($val) eq '' &&
       $val =~ /^\d+([eE]\+?(\d+))?$/)
      {return(1)}

    return(0);

  }

sub getSubPairNum
  {
    my $group1    = [sort(@{$_[0]})];
    my $group2    = [sort(@{$_[1]})];
    my $pair_hash = $_[2];

    my $num = 1;
    my($lesser_group,$greater_group) = ($group1->[0] lt $group2->[0] ?
					($group1,$group2) : ($group2,$group1));
    my $key = join('_X_',@$lesser_group) . '_Y_' . join('_Z_',@$greater_group);
    if(scalar(keys(%$pair_hash)) == 0)
      {%$pair_hash = (LAST => 1,
		      LKUP => {$key => 1})}
    elsif(exists($pair_hash->{LKUP}->{$key}))
      {$num = $pair_hash->{LKUP}->{$key}}
    else
      {
	$pair_hash->{LAST}++;
	$pair_hash->{LKUP}->{$key} = $pair_hash->{LAST};
	$num = $pair_hash->{LAST};
      }

    return($num);
  }
